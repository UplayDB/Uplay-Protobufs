// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: download.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Uplay.Download {

  /// <summary>Holder for reflection information generated from download.proto</summary>
  public static partial class DownloadReflection {

    #region Descriptor
    /// <summary>File descriptor for download.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DownloadReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chp1cGNfZHVtcF8xMC9kb3dubG9hZC5wcm90bxIUbWcucHJvdG9jb2wuZG93",
            "bmxvYWQiSwoNTGljZW5zZUxvY2FsZRIQCghsYW5ndWFnZRgBIAIoCRIMCgRz",
            "aGExGAIgAigMEgwKBHRleHQYAyABKAkSDAoEbmFtZRgEIAEoCSKZAQoHTGlj",
            "ZW5zZRISCgppZGVudGlmaWVyGAEgAigJEg8KB3ZlcnNpb24YAiACKA0SNAoH",
            "bG9jYWxlcxgDIAMoCzIjLm1nLnByb3RvY29sLmRvd25sb2FkLkxpY2Vuc2VM",
            "b2NhbGUSMwoGZm9ybWF0GAQgASgOMiMubWcucHJvdG9jb2wuZG93bmxvYWQu",
            "TGljZW5zZUZvcm1hdCKbAgoKSW5zdGFsbFJ1bhILCgNleGUYASACKAkSEgoK",
            "d29ya2luZ0RpchgCIAIoCRIRCglhcmd1bWVudHMYAyACKAkSEwoLZGVzY3Jp",
            "cHRpb24YBCACKAkSEgoKaWRlbnRpZmllchgFIAEoCRIPCgd2ZXJzaW9uGAYg",
            "ASgNEjAKCHBsYXRmb3JtGAcgASgOMh4ubWcucHJvdG9jb2wuZG93bmxvYWQu",
            "UGxhdGZvcm0SOAoMcGxhdGZvcm1UeXBlGAggASgOMiIubWcucHJvdG9jb2wu",
            "ZG93bmxvYWQuUGxhdGZvcm1UeXBlEhoKEmlnbm9yZUFsbEV4aXRDb2RlcxgJ",
            "IAEoCBIXCg9yZXN0YXJ0UmVxdWlyZWQYCiABKAgiNgoTUmVnaXN0cnlTdHJp",
            "bmdFbnRyeRINCgV2YWx1ZRgBIAIoCRIQCghsYW5ndWFnZRgCIAEoCSI2ChNS",
            "ZWdpc3RyeU51bWJlckVudHJ5Eg0KBXZhbHVlGAEgAigNEhAKCGxhbmd1YWdl",
            "GAIgASgJIqYCCg9JbnN0YWxsUmVnaXN0cnkSCwoDa2V5GAEgAigJEj0KBHR5",
            "cGUYAiACKA4yLy5tZy5wcm90b2NvbC5kb3dubG9hZC5JbnN0YWxsUmVnaXN0",
            "cnkuVmFsdWVUeXBlEkYKE3JlZ2lzdHJ5U3RyaW5nRW50cnkYAyADKAsyKS5t",
            "Zy5wcm90b2NvbC5kb3dubG9hZC5SZWdpc3RyeVN0cmluZ0VudHJ5EkYKE3Jl",
            "Z2lzdHJ5TnVtYmVyRW50cnkYBCADKAsyKS5tZy5wcm90b2NvbC5kb3dubG9h",
            "ZC5SZWdpc3RyeU51bWJlckVudHJ5IjcKCVZhbHVlVHlwZRIUChBWYWx1ZVR5",
            "cGVfU3RyaW5nEAASFAoQVmFsdWVUeXBlX051bWJlchABIjcKE0luc3RhbGxH",
            "YW1lRXhwbG9yZXISDwoHZ2RmUGF0aBgBIAIoCRIPCgd2ZXJzaW9uGAIgASgN",
            "IsIBChNJbnN0YWxsRmlyZXdhbGxSdWxlEgwKBG5hbWUYASACKAkSCwoDZXhl",
            "GAIgAigJEjYKB3Byb2ZpbGUYAyACKA4yJS5tZy5wcm90b2NvbC5kb3dubG9h",
            "ZC5GaXJld2FsbFByb2ZpbGUSOAoIcHJvdG9jb2wYBCACKA4yJi5tZy5wcm90",
            "b2NvbC5kb3dubG9hZC5GaXJld2FsbFByb3RvY29sEg0KBXBvcnRzGAUgASgJ",
            "Eg8KB3ZlcnNpb24YBiABKA0iZgoUSW5zdGFsbENvbXBhdGliaWxpdHkSCwoD",
            "ZXhlGAEgAigJEg8KB29wdGlvbnMYAiACKAkSMAoIcGxhdGZvcm0YAyABKA4y",
            "Hi5tZy5wcm90b2NvbC5kb3dubG9hZC5QbGF0Zm9ybSKuAQoMVW5pbnN0YWxs",
            "UnVuEgsKA2V4ZRgBIAIoCRISCgp3b3JraW5nRGlyGAIgAigJEhEKCWFyZ3Vt",
            "ZW50cxgDIAIoCRIwCghwbGF0Zm9ybRgFIAEoDjIeLm1nLnByb3RvY29sLmRv",
            "d25sb2FkLlBsYXRmb3JtEjgKDHBsYXRmb3JtVHlwZRgGIAEoDjIiLm1nLnBy",
            "b3RvY29sLmRvd25sb2FkLlBsYXRmb3JtVHlwZSIgChFVbmluc3RhbGxSZWdp",
            "c3RyeRILCgNrZXkYASACKAkiVQoFU2xpY2USDAoEc2l6ZRgBIAIoDRIUCgxk",
            "b3dubG9hZFNpemUYAiABKA0SFAoMZG93bmxvYWRTaGExGAMgASgMEhIKCmZp",
            "bGVPZmZzZXQYBCABKAQilgEKBEZpbGUSDAoEbmFtZRgBIAIoCRIMCgRzaXpl",
            "GAIgAigEEg0KBWlzRGlyGAMgAigIEg4KBnNsaWNlcxgEIAMoDBIPCgd2ZXJz",
            "aW9uGAUgASgNEhIKCnBhZGRlZFNpemUYBiABKAQSLgoJc2xpY2VMaXN0GAcg",
            "AygLMhsubWcucHJvdG9jb2wuZG93bmxvYWQuU2xpY2UigQIKBUNodW5rEgoK",
            "AmlkGAEgAigNEjMKBHR5cGUYAiACKA4yJS5tZy5wcm90b2NvbC5kb3dubG9h",
            "ZC5DaHVuay5DaHVua1R5cGUSKQoFZmlsZXMYAyADKAsyGi5tZy5wcm90b2Nv",
            "bC5kb3dubG9hZC5GaWxlEg8KB3VwbGF5SWQYBCABKA0SEAoIbGFuZ3VhZ2UY",
            "BSABKAkSDAoEZGlzYxgGIAEoCRIMCgR0YWdzGAcgASgJEhAKCHVwbGF5SWRz",
            "GAggAygNIjsKCUNodW5rVHlwZRIWChJDaHVua1R5cGVfUmVxdWlyZWQQABIW",
            "ChJDaHVua1R5cGVfT3B0aW9uYWwQASJ0Cg1NZXRhRGF0YUNodW5rEg8KB3Vw",
            "bGF5SWQYASABKA0SEAoIbGFuZ3VhZ2UYAiABKAkSEwoLYnl0ZXNPbkRpc2sY",
            "AyACKAQSGQoRcGFkZGVkQnl0ZXNPbkRpc2sYBCABKAQSEAoIdXBsYXlJZHMY",
            "BSADKA0iMQoNVGV4dEZpbGVFbnRyeRIQCghmaWxlTmFtZRgBIAIoCRIOCgZs",
            "b2NhbGUYAiACKAkiVAoMVGV4dEZpbGVMaXN0EhAKCHJvb3RQYXRoGAEgASgJ",
            "EjIKBWZpbGVzGAIgAygLMiMubWcucHJvdG9jb2wuZG93bmxvYWQuVGV4dEZp",
            "bGVFbnRyeSIqCghMYW5ndWFnZRIMCgRjb2RlGAEgASgJEhAKCHVwbGF5SWRz",
            "GAIgAygNIuIBCgxTbGljZXJDb25maWcSQQoKc2xpY2VyVHlwZRgBIAEoDjIt",
            "Lm1nLnByb3RvY29sLmRvd25sb2FkLlNsaWNlckNvbmZpZy5TbGljZXJUeXBl",
            "EhkKEW1pblNsaWNlU2l6ZUJ5dGVzGAIgASgNEh4KFmV4cGVjdGVkU2xpY2VT",
            "aXplQnl0ZXMYAyABKA0SGQoRbWF4U2xpY2VTaXplQnl0ZXMYBCABKA0SFQoN",
            "Y29uZmlnVmVyc2lvbhgFIAEoDSIiCgpTbGljZXJUeXBlEgcKA0ZzYxABEgsK",
            "B0Zhc3RDZGMQAiLbCAoITWFuaWZlc3QSLwoIbGljZW5zZXMYASADKAsyHS5t",
            "Zy5wcm90b2NvbC5kb3dubG9hZC5MaWNlbnNlEjUKC2luc3RhbGxSdW5zGAIg",
            "AygLMiAubWcucHJvdG9jb2wuZG93bmxvYWQuSW5zdGFsbFJ1bhI+Cg9pbnN0",
            "YWxsUmVnaXN0cnkYBSADKAsyJS5tZy5wcm90b2NvbC5kb3dubG9hZC5JbnN0",
            "YWxsUmVnaXN0cnkSOQoNdW5pbnN0YWxsUnVucxgDIAMoCzIiLm1nLnByb3Rv",
            "Y29sLmRvd25sb2FkLlVuaW5zdGFsbFJ1bhJCChF1bmluc3RhbGxSZWdpc3Ry",
            "eRgGIAMoCzInLm1nLnByb3RvY29sLmRvd25sb2FkLlVuaW5zdGFsbFJlZ2lz",
            "dHJ5EisKBmNodW5rcxgEIAMoCzIbLm1nLnByb3RvY29sLmRvd25sb2FkLkNo",
            "dW5rEhUKDWNodW5rc1ZlcnNpb24YByABKA0SGwoTc2xpY2VTaXplRGVwcmVj",
            "YXRlZBgIIAEoDRJGChNpbnN0YWxsR2FtZUV4cGxvcmVyGAkgAygLMikubWcu",
            "cHJvdG9jb2wuZG93bmxvYWQuSW5zdGFsbEdhbWVFeHBsb3JlchJHChRpbnN0",
            "YWxsRmlyZXdhbGxSdWxlcxgKIAMoCzIpLm1nLnByb3RvY29sLmRvd25sb2Fk",
            "Lkluc3RhbGxGaXJld2FsbFJ1bGUSSAoUaW5zdGFsbENvbXBhdGliaWxpdHkY",
            "CyADKAsyKi5tZy5wcm90b2NvbC5kb3dubG9hZC5JbnN0YWxsQ29tcGF0aWJp",
            "bGl0eRIXCg9sZWdhY3lJbnN0YWxsZXIYDCABKAkSGwoTZGVwcmVjYXRlZExh",
            "bmd1YWdlcxgNIAMoCRIdChVpc0VuY3J5cHRlZERlcHJlY2F0ZWQYDiABKAgS",
            "IQoZcGFkZGVkU2xpY2VTaXplRGVwcmVjYXRlZBgPIAEoDRIVCg1wYXRjaFJl",
            "cXVpcmVkGBAgASgIEhQKDGlzQ29tcHJlc3NlZBgRIAEoCBI3CgtyZWFkbWVG",
            "aWxlcxgSIAEoCzIiLm1nLnByb3RvY29sLmRvd25sb2FkLlRleHRGaWxlTGlz",
            "dBI3CgttYW51YWxGaWxlcxgTIAEoCzIiLm1nLnByb3RvY29sLmRvd25sb2Fk",
            "LlRleHRGaWxlTGlzdBITCgtnYW1lVmVyc2lvbhgUIAEoCRJCChFjb21wcmVz",
            "c2lvbk1ldGhvZBgVIAEoDjInLm1nLnByb3RvY29sLmRvd25sb2FkLkNvbXBy",
            "ZXNzaW9uTWV0aG9kEg8KB3ZlcnNpb24YFiABKA0SMQoJbGFuZ3VhZ2VzGBcg",
            "AygLMh4ubWcucHJvdG9jb2wuZG93bmxvYWQuTGFuZ3VhZ2USOAoMc2xpY2Vy",
            "Q29uZmlnGBggASgLMiIubWcucHJvdG9jb2wuZG93bmxvYWQuU2xpY2VyQ29u",
            "ZmlnIkMKEE1hbmlmZXN0TGljZW5zZXMSLwoIbGljZW5zZXMYASADKAsyHS5t",
            "Zy5wcm90b2NvbC5kb3dubG9hZC5MaWNlbnNlIroCChBNYW5pZmVzdE1ldGFE",
            "YXRhEi8KCGxpY2Vuc2VzGAEgAygLMh0ubWcucHJvdG9jb2wuZG93bmxvYWQu",
            "TGljZW5zZRITCgtieXRlc09uRGlzaxgCIAIoBBIXCg9ieXRlc1RvRG93bmxv",
            "YWQYAyACKAQSGwoTZGVwcmVjYXRlZExhbmd1YWdlcxgFIAMoCRIVCg1jaHVu",
            "a3NWZXJzaW9uGAYgASgNEhAKCHVwbGF5SWRzGAcgAygNEjMKBmNodW5rcxgI",
            "IAMoCzIjLm1nLnByb3RvY29sLmRvd25sb2FkLk1ldGFEYXRhQ2h1bmsSGQoR",
            "cGFkZGVkQnl0ZXNPbkRpc2sYCSABKAQSMQoJbGFuZ3VhZ2VzGAogAygLMh4u",
            "bWcucHJvdG9jb2wuZG93bmxvYWQuTGFuZ3VhZ2UqPwoNTGljZW5zZUZvcm1h",
            "dBIWChJMaWNlbnNlRm9ybWF0X1RleHQQARIWChJMaWNlbnNlRm9ybWF0X0h0",
            "bWwQAiqbAQoIUGxhdGZvcm0SFgoSUGxhdGZvcm1fV2luZG93c1hQEAESGQoV",
            "UGxhdGZvcm1fV2luZG93c1Zpc3RhEAISFQoRUGxhdGZvcm1fV2luZG93czcQ",
            "AxIVChFQbGF0Zm9ybV9XaW5kb3dzOBAEEhYKElBsYXRmb3JtX1dpbmRvd3Mx",
            "MBAFEhYKElBsYXRmb3JtX1dpbmRvd3M4MRAGKjoKDFBsYXRmb3JtVHlwZRIU",
            "ChBQbGF0Zm9ybVR5cGVfeDg2EAESFAoQUGxhdGZvcm1UeXBlX3g2NBACKn8K",
            "D0ZpcmV3YWxsUHJvZmlsZRIaChZGaXJld2FsbFByb2ZpbGVfRG9tYWluEAES",
            "GwoXRmlyZXdhbGxQcm9maWxlX1ByaXZhdGUQAhIaChZGaXJld2FsbFByb2Zp",
            "bGVfUHVibGljEAMSFwoTRmlyZXdhbGxQcm9maWxlX0FsbBAEKkYKEEZpcmV3",
            "YWxsUHJvdG9jb2wSGAoURmlyZXdhbGxQcm90b2NvbF9UQ1AQARIYChRGaXJl",
            "d2FsbFByb3RvY29sX1VEUBACKmsKEUNvbXByZXNzaW9uTWV0aG9kEh0KGUNv",
            "bXByZXNzaW9uTWV0aG9kX0RlZmxhdGUQARIbChdDb21wcmVzc2lvbk1ldGhv",
            "ZF9MemhhbRACEhoKFkNvbXByZXNzaW9uTWV0aG9kX1pzdGQQAw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Uplay.Download.LicenseFormat), typeof(global::Uplay.Download.Platform), typeof(global::Uplay.Download.PlatformType), typeof(global::Uplay.Download.FirewallProfile), typeof(global::Uplay.Download.FirewallProtocol), typeof(global::Uplay.Download.CompressionMethod), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.LicenseLocale), global::Uplay.Download.LicenseLocale.Parser, new[]{ "Language", "Sha1", "Text", "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.License), global::Uplay.Download.License.Parser, new[]{ "Identifier", "Version", "Locales", "Format" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.InstallRun), global::Uplay.Download.InstallRun.Parser, new[]{ "Exe", "WorkingDir", "Arguments", "Description", "Identifier", "Version", "Platform", "PlatformType", "IgnoreAllExitCodes", "RestartRequired" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.RegistryStringEntry), global::Uplay.Download.RegistryStringEntry.Parser, new[]{ "Value", "Language" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.RegistryNumberEntry), global::Uplay.Download.RegistryNumberEntry.Parser, new[]{ "Value", "Language" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.InstallRegistry), global::Uplay.Download.InstallRegistry.Parser, new[]{ "Key", "Type", "RegistryStringEntry", "RegistryNumberEntry" }, null, new[]{ typeof(global::Uplay.Download.InstallRegistry.Types.ValueType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.InstallGameExplorer), global::Uplay.Download.InstallGameExplorer.Parser, new[]{ "GdfPath", "Version" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.InstallFirewallRule), global::Uplay.Download.InstallFirewallRule.Parser, new[]{ "Name", "Exe", "Profile", "Protocol", "Ports", "Version" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.InstallCompatibility), global::Uplay.Download.InstallCompatibility.Parser, new[]{ "Exe", "Options", "Platform" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.UninstallRun), global::Uplay.Download.UninstallRun.Parser, new[]{ "Exe", "WorkingDir", "Arguments", "Platform", "PlatformType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.UninstallRegistry), global::Uplay.Download.UninstallRegistry.Parser, new[]{ "Key" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.Slice), global::Uplay.Download.Slice.Parser, new[]{ "Size", "DownloadSize", "DownloadSha1", "FileOffset" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.File), global::Uplay.Download.File.Parser, new[]{ "Name", "Size", "IsDir", "Slices", "Version", "PaddedSize", "SliceList" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.Chunk), global::Uplay.Download.Chunk.Parser, new[]{ "Id", "Type", "Files", "UplayId", "Language", "Disc", "Tags", "UplayIds" }, null, new[]{ typeof(global::Uplay.Download.Chunk.Types.ChunkType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.MetaDataChunk), global::Uplay.Download.MetaDataChunk.Parser, new[]{ "UplayId", "Language", "BytesOnDisk", "PaddedBytesOnDisk", "UplayIds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.TextFileEntry), global::Uplay.Download.TextFileEntry.Parser, new[]{ "FileName", "Locale" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.TextFileList), global::Uplay.Download.TextFileList.Parser, new[]{ "RootPath", "Files" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.Language), global::Uplay.Download.Language.Parser, new[]{ "Code", "UplayIds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.SlicerConfig), global::Uplay.Download.SlicerConfig.Parser, new[]{ "SlicerType", "MinSliceSizeBytes", "ExpectedSliceSizeBytes", "MaxSliceSizeBytes", "ConfigVersion" }, null, new[]{ typeof(global::Uplay.Download.SlicerConfig.Types.SlicerType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.Manifest), global::Uplay.Download.Manifest.Parser, new[]{ "Licenses", "InstallRuns", "InstallRegistry", "UninstallRuns", "UninstallRegistry", "Chunks", "ChunksVersion", "SliceSizeDeprecated", "InstallGameExplorer", "InstallFirewallRules", "InstallCompatibility", "LegacyInstaller", "DeprecatedLanguages", "IsEncryptedDeprecated", "PaddedSliceSizeDeprecated", "PatchRequired", "IsCompressed", "ReadmeFiles", "ManualFiles", "GameVersion", "CompressionMethod", "Version", "Languages", "SlicerConfig" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.ManifestLicenses), global::Uplay.Download.ManifestLicenses.Parser, new[]{ "Licenses" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.Download.ManifestMetaData), global::Uplay.Download.ManifestMetaData.Parser, new[]{ "Licenses", "BytesOnDisk", "BytesToDownload", "DeprecatedLanguages", "ChunksVersion", "UplayIds", "Chunks", "PaddedBytesOnDisk", "Languages" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum LicenseFormat {
    [pbr::OriginalName("LicenseFormat_Text")] Text = 1,
    [pbr::OriginalName("LicenseFormat_Html")] Html = 2,
  }

  public enum Platform {
    [pbr::OriginalName("Platform_WindowsXP")] WindowsXp = 1,
    [pbr::OriginalName("Platform_WindowsVista")] WindowsVista = 2,
    [pbr::OriginalName("Platform_Windows7")] Windows7 = 3,
    [pbr::OriginalName("Platform_Windows8")] Windows8 = 4,
    [pbr::OriginalName("Platform_Windows10")] Windows10 = 5,
    [pbr::OriginalName("Platform_Windows81")] Windows81 = 6,
  }

  public enum PlatformType {
    [pbr::OriginalName("PlatformType_x86")] X86 = 1,
    [pbr::OriginalName("PlatformType_x64")] X64 = 2,
  }

  public enum FirewallProfile {
    [pbr::OriginalName("FirewallProfile_Domain")] Domain = 1,
    [pbr::OriginalName("FirewallProfile_Private")] Private = 2,
    [pbr::OriginalName("FirewallProfile_Public")] Public = 3,
    [pbr::OriginalName("FirewallProfile_All")] All = 4,
  }

  public enum FirewallProtocol {
    [pbr::OriginalName("FirewallProtocol_TCP")] Tcp = 1,
    [pbr::OriginalName("FirewallProtocol_UDP")] Udp = 2,
  }

  public enum CompressionMethod {
    [pbr::OriginalName("CompressionMethod_Deflate")] Deflate = 1,
    [pbr::OriginalName("CompressionMethod_Lzham")] Lzham = 2,
    [pbr::OriginalName("CompressionMethod_Zstd")] Zstd = 3,
  }

  #endregion

  #region Messages
  public sealed partial class LicenseLocale : pb::IMessage<LicenseLocale>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LicenseLocale> _parser = new pb::MessageParser<LicenseLocale>(() => new LicenseLocale());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LicenseLocale> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseLocale() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseLocale(LicenseLocale other) : this() {
      language_ = other.language_;
      sha1_ = other.sha1_;
      text_ = other.text_;
      name_ = other.name_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseLocale Clone() {
      return new LicenseLocale(this);
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 1;
    private readonly static string LanguageDefaultValue = "";

    private string language_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_ ?? LanguageDefaultValue; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "language" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLanguage {
      get { return language_ != null; }
    }
    /// <summary>Clears the value of the "language" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLanguage() {
      language_ = null;
    }

    /// <summary>Field number for the "sha1" field.</summary>
    public const int Sha1FieldNumber = 2;
    private readonly static pb::ByteString Sha1DefaultValue = pb::ByteString.Empty;

    private pb::ByteString sha1_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Sha1 {
      get { return sha1_ ?? Sha1DefaultValue; }
      set {
        sha1_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sha1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSha1 {
      get { return sha1_ != null; }
    }
    /// <summary>Clears the value of the "sha1" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSha1() {
      sha1_ = null;
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 3;
    private readonly static string TextDefaultValue = "";

    private string text_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Text {
      get { return text_ ?? TextDefaultValue; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasText {
      get { return text_ != null; }
    }
    /// <summary>Clears the value of the "text" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearText() {
      text_ = null;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 4;
    private readonly static string NameDefaultValue = "";

    private string name_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LicenseLocale);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LicenseLocale other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Language != other.Language) return false;
      if (Sha1 != other.Sha1) return false;
      if (Text != other.Text) return false;
      if (Name != other.Name) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLanguage) hash ^= Language.GetHashCode();
      if (HasSha1) hash ^= Sha1.GetHashCode();
      if (HasText) hash ^= Text.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasLanguage) {
        output.WriteRawTag(10);
        output.WriteString(Language);
      }
      if (HasSha1) {
        output.WriteRawTag(18);
        output.WriteBytes(Sha1);
      }
      if (HasText) {
        output.WriteRawTag(26);
        output.WriteString(Text);
      }
      if (HasName) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasLanguage) {
        output.WriteRawTag(10);
        output.WriteString(Language);
      }
      if (HasSha1) {
        output.WriteRawTag(18);
        output.WriteBytes(Sha1);
      }
      if (HasText) {
        output.WriteRawTag(26);
        output.WriteString(Text);
      }
      if (HasName) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasLanguage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (HasSha1) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Sha1);
      }
      if (HasText) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LicenseLocale other) {
      if (other == null) {
        return;
      }
      if (other.HasLanguage) {
        Language = other.Language;
      }
      if (other.HasSha1) {
        Sha1 = other.Sha1;
      }
      if (other.HasText) {
        Text = other.Text;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Language = input.ReadString();
            break;
          }
          case 18: {
            Sha1 = input.ReadBytes();
            break;
          }
          case 26: {
            Text = input.ReadString();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Language = input.ReadString();
            break;
          }
          case 18: {
            Sha1 = input.ReadBytes();
            break;
          }
          case 26: {
            Text = input.ReadString();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class License : pb::IMessage<License>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<License> _parser = new pb::MessageParser<License>(() => new License());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<License> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License(License other) : this() {
      _hasBits0 = other._hasBits0;
      identifier_ = other.identifier_;
      version_ = other.version_;
      locales_ = other.locales_.Clone();
      format_ = other.format_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License Clone() {
      return new License(this);
    }

    /// <summary>Field number for the "identifier" field.</summary>
    public const int IdentifierFieldNumber = 1;
    private readonly static string IdentifierDefaultValue = "";

    private string identifier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Identifier {
      get { return identifier_ ?? IdentifierDefaultValue; }
      set {
        identifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "identifier" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIdentifier {
      get { return identifier_ != null; }
    }
    /// <summary>Clears the value of the "identifier" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIdentifier() {
      identifier_ = null;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private readonly static uint VersionDefaultValue = 0;

    private uint version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Version {
      get { if ((_hasBits0 & 1) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "locales" field.</summary>
    public const int LocalesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.Download.LicenseLocale> _repeated_locales_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.Download.LicenseLocale.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.LicenseLocale> locales_ = new pbc::RepeatedField<global::Uplay.Download.LicenseLocale>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.LicenseLocale> Locales {
      get { return locales_; }
    }

    /// <summary>Field number for the "format" field.</summary>
    public const int FormatFieldNumber = 4;
    private readonly static global::Uplay.Download.LicenseFormat FormatDefaultValue = global::Uplay.Download.LicenseFormat.Text;

    private global::Uplay.Download.LicenseFormat format_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.LicenseFormat Format {
      get { if ((_hasBits0 & 2) != 0) { return format_; } else { return FormatDefaultValue; } }
      set {
        _hasBits0 |= 2;
        format_ = value;
      }
    }
    /// <summary>Gets whether the "format" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFormat {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "format" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFormat() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as License);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(License other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Identifier != other.Identifier) return false;
      if (Version != other.Version) return false;
      if(!locales_.Equals(other.locales_)) return false;
      if (Format != other.Format) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIdentifier) hash ^= Identifier.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      hash ^= locales_.GetHashCode();
      if (HasFormat) hash ^= Format.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIdentifier) {
        output.WriteRawTag(10);
        output.WriteString(Identifier);
      }
      if (HasVersion) {
        output.WriteRawTag(16);
        output.WriteUInt32(Version);
      }
      locales_.WriteTo(output, _repeated_locales_codec);
      if (HasFormat) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Format);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIdentifier) {
        output.WriteRawTag(10);
        output.WriteString(Identifier);
      }
      if (HasVersion) {
        output.WriteRawTag(16);
        output.WriteUInt32(Version);
      }
      locales_.WriteTo(ref output, _repeated_locales_codec);
      if (HasFormat) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Format);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIdentifier) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Identifier);
      }
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
      }
      size += locales_.CalculateSize(_repeated_locales_codec);
      if (HasFormat) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Format);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(License other) {
      if (other == null) {
        return;
      }
      if (other.HasIdentifier) {
        Identifier = other.Identifier;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      locales_.Add(other.locales_);
      if (other.HasFormat) {
        Format = other.Format;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Identifier = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadUInt32();
            break;
          }
          case 26: {
            locales_.AddEntriesFrom(input, _repeated_locales_codec);
            break;
          }
          case 32: {
            Format = (global::Uplay.Download.LicenseFormat) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Identifier = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadUInt32();
            break;
          }
          case 26: {
            locales_.AddEntriesFrom(ref input, _repeated_locales_codec);
            break;
          }
          case 32: {
            Format = (global::Uplay.Download.LicenseFormat) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class InstallRun : pb::IMessage<InstallRun>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstallRun> _parser = new pb::MessageParser<InstallRun>(() => new InstallRun());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InstallRun> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallRun() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallRun(InstallRun other) : this() {
      _hasBits0 = other._hasBits0;
      exe_ = other.exe_;
      workingDir_ = other.workingDir_;
      arguments_ = other.arguments_;
      description_ = other.description_;
      identifier_ = other.identifier_;
      version_ = other.version_;
      platform_ = other.platform_;
      platformType_ = other.platformType_;
      ignoreAllExitCodes_ = other.ignoreAllExitCodes_;
      restartRequired_ = other.restartRequired_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallRun Clone() {
      return new InstallRun(this);
    }

    /// <summary>Field number for the "exe" field.</summary>
    public const int ExeFieldNumber = 1;
    private readonly static string ExeDefaultValue = "";

    private string exe_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Exe {
      get { return exe_ ?? ExeDefaultValue; }
      set {
        exe_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "exe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExe {
      get { return exe_ != null; }
    }
    /// <summary>Clears the value of the "exe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExe() {
      exe_ = null;
    }

    /// <summary>Field number for the "workingDir" field.</summary>
    public const int WorkingDirFieldNumber = 2;
    private readonly static string WorkingDirDefaultValue = "";

    private string workingDir_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string WorkingDir {
      get { return workingDir_ ?? WorkingDirDefaultValue; }
      set {
        workingDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "workingDir" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWorkingDir {
      get { return workingDir_ != null; }
    }
    /// <summary>Clears the value of the "workingDir" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWorkingDir() {
      workingDir_ = null;
    }

    /// <summary>Field number for the "arguments" field.</summary>
    public const int ArgumentsFieldNumber = 3;
    private readonly static string ArgumentsDefaultValue = "";

    private string arguments_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Arguments {
      get { return arguments_ ?? ArgumentsDefaultValue; }
      set {
        arguments_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "arguments" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasArguments {
      get { return arguments_ != null; }
    }
    /// <summary>Clears the value of the "arguments" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearArguments() {
      arguments_ = null;
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 4;
    private readonly static string DescriptionDefaultValue = "";

    private string description_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Description {
      get { return description_ ?? DescriptionDefaultValue; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDescription {
      get { return description_ != null; }
    }
    /// <summary>Clears the value of the "description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDescription() {
      description_ = null;
    }

    /// <summary>Field number for the "identifier" field.</summary>
    public const int IdentifierFieldNumber = 5;
    private readonly static string IdentifierDefaultValue = "";

    private string identifier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Identifier {
      get { return identifier_ ?? IdentifierDefaultValue; }
      set {
        identifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "identifier" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIdentifier {
      get { return identifier_ != null; }
    }
    /// <summary>Clears the value of the "identifier" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIdentifier() {
      identifier_ = null;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 6;
    private readonly static uint VersionDefaultValue = 0;

    private uint version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Version {
      get { if ((_hasBits0 & 1) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "platform" field.</summary>
    public const int PlatformFieldNumber = 7;
    private readonly static global::Uplay.Download.Platform PlatformDefaultValue = global::Uplay.Download.Platform.WindowsXp;

    private global::Uplay.Download.Platform platform_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.Platform Platform {
      get { if ((_hasBits0 & 2) != 0) { return platform_; } else { return PlatformDefaultValue; } }
      set {
        _hasBits0 |= 2;
        platform_ = value;
      }
    }
    /// <summary>Gets whether the "platform" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPlatform {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "platform" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPlatform() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "platformType" field.</summary>
    public const int PlatformTypeFieldNumber = 8;
    private readonly static global::Uplay.Download.PlatformType PlatformTypeDefaultValue = global::Uplay.Download.PlatformType.X86;

    private global::Uplay.Download.PlatformType platformType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.PlatformType PlatformType {
      get { if ((_hasBits0 & 4) != 0) { return platformType_; } else { return PlatformTypeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        platformType_ = value;
      }
    }
    /// <summary>Gets whether the "platformType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPlatformType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "platformType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPlatformType() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "ignoreAllExitCodes" field.</summary>
    public const int IgnoreAllExitCodesFieldNumber = 9;
    private readonly static bool IgnoreAllExitCodesDefaultValue = false;

    private bool ignoreAllExitCodes_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IgnoreAllExitCodes {
      get { if ((_hasBits0 & 8) != 0) { return ignoreAllExitCodes_; } else { return IgnoreAllExitCodesDefaultValue; } }
      set {
        _hasBits0 |= 8;
        ignoreAllExitCodes_ = value;
      }
    }
    /// <summary>Gets whether the "ignoreAllExitCodes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIgnoreAllExitCodes {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "ignoreAllExitCodes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIgnoreAllExitCodes() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "restartRequired" field.</summary>
    public const int RestartRequiredFieldNumber = 10;
    private readonly static bool RestartRequiredDefaultValue = false;

    private bool restartRequired_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RestartRequired {
      get { if ((_hasBits0 & 16) != 0) { return restartRequired_; } else { return RestartRequiredDefaultValue; } }
      set {
        _hasBits0 |= 16;
        restartRequired_ = value;
      }
    }
    /// <summary>Gets whether the "restartRequired" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRestartRequired {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "restartRequired" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRestartRequired() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InstallRun);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InstallRun other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Exe != other.Exe) return false;
      if (WorkingDir != other.WorkingDir) return false;
      if (Arguments != other.Arguments) return false;
      if (Description != other.Description) return false;
      if (Identifier != other.Identifier) return false;
      if (Version != other.Version) return false;
      if (Platform != other.Platform) return false;
      if (PlatformType != other.PlatformType) return false;
      if (IgnoreAllExitCodes != other.IgnoreAllExitCodes) return false;
      if (RestartRequired != other.RestartRequired) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasExe) hash ^= Exe.GetHashCode();
      if (HasWorkingDir) hash ^= WorkingDir.GetHashCode();
      if (HasArguments) hash ^= Arguments.GetHashCode();
      if (HasDescription) hash ^= Description.GetHashCode();
      if (HasIdentifier) hash ^= Identifier.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      if (HasPlatform) hash ^= Platform.GetHashCode();
      if (HasPlatformType) hash ^= PlatformType.GetHashCode();
      if (HasIgnoreAllExitCodes) hash ^= IgnoreAllExitCodes.GetHashCode();
      if (HasRestartRequired) hash ^= RestartRequired.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasExe) {
        output.WriteRawTag(10);
        output.WriteString(Exe);
      }
      if (HasWorkingDir) {
        output.WriteRawTag(18);
        output.WriteString(WorkingDir);
      }
      if (HasArguments) {
        output.WriteRawTag(26);
        output.WriteString(Arguments);
      }
      if (HasDescription) {
        output.WriteRawTag(34);
        output.WriteString(Description);
      }
      if (HasIdentifier) {
        output.WriteRawTag(42);
        output.WriteString(Identifier);
      }
      if (HasVersion) {
        output.WriteRawTag(48);
        output.WriteUInt32(Version);
      }
      if (HasPlatform) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Platform);
      }
      if (HasPlatformType) {
        output.WriteRawTag(64);
        output.WriteEnum((int) PlatformType);
      }
      if (HasIgnoreAllExitCodes) {
        output.WriteRawTag(72);
        output.WriteBool(IgnoreAllExitCodes);
      }
      if (HasRestartRequired) {
        output.WriteRawTag(80);
        output.WriteBool(RestartRequired);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasExe) {
        output.WriteRawTag(10);
        output.WriteString(Exe);
      }
      if (HasWorkingDir) {
        output.WriteRawTag(18);
        output.WriteString(WorkingDir);
      }
      if (HasArguments) {
        output.WriteRawTag(26);
        output.WriteString(Arguments);
      }
      if (HasDescription) {
        output.WriteRawTag(34);
        output.WriteString(Description);
      }
      if (HasIdentifier) {
        output.WriteRawTag(42);
        output.WriteString(Identifier);
      }
      if (HasVersion) {
        output.WriteRawTag(48);
        output.WriteUInt32(Version);
      }
      if (HasPlatform) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Platform);
      }
      if (HasPlatformType) {
        output.WriteRawTag(64);
        output.WriteEnum((int) PlatformType);
      }
      if (HasIgnoreAllExitCodes) {
        output.WriteRawTag(72);
        output.WriteBool(IgnoreAllExitCodes);
      }
      if (HasRestartRequired) {
        output.WriteRawTag(80);
        output.WriteBool(RestartRequired);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasExe) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Exe);
      }
      if (HasWorkingDir) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WorkingDir);
      }
      if (HasArguments) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Arguments);
      }
      if (HasDescription) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (HasIdentifier) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Identifier);
      }
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
      }
      if (HasPlatform) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Platform);
      }
      if (HasPlatformType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PlatformType);
      }
      if (HasIgnoreAllExitCodes) {
        size += 1 + 1;
      }
      if (HasRestartRequired) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InstallRun other) {
      if (other == null) {
        return;
      }
      if (other.HasExe) {
        Exe = other.Exe;
      }
      if (other.HasWorkingDir) {
        WorkingDir = other.WorkingDir;
      }
      if (other.HasArguments) {
        Arguments = other.Arguments;
      }
      if (other.HasDescription) {
        Description = other.Description;
      }
      if (other.HasIdentifier) {
        Identifier = other.Identifier;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      if (other.HasPlatform) {
        Platform = other.Platform;
      }
      if (other.HasPlatformType) {
        PlatformType = other.PlatformType;
      }
      if (other.HasIgnoreAllExitCodes) {
        IgnoreAllExitCodes = other.IgnoreAllExitCodes;
      }
      if (other.HasRestartRequired) {
        RestartRequired = other.RestartRequired;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Exe = input.ReadString();
            break;
          }
          case 18: {
            WorkingDir = input.ReadString();
            break;
          }
          case 26: {
            Arguments = input.ReadString();
            break;
          }
          case 34: {
            Description = input.ReadString();
            break;
          }
          case 42: {
            Identifier = input.ReadString();
            break;
          }
          case 48: {
            Version = input.ReadUInt32();
            break;
          }
          case 56: {
            Platform = (global::Uplay.Download.Platform) input.ReadEnum();
            break;
          }
          case 64: {
            PlatformType = (global::Uplay.Download.PlatformType) input.ReadEnum();
            break;
          }
          case 72: {
            IgnoreAllExitCodes = input.ReadBool();
            break;
          }
          case 80: {
            RestartRequired = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Exe = input.ReadString();
            break;
          }
          case 18: {
            WorkingDir = input.ReadString();
            break;
          }
          case 26: {
            Arguments = input.ReadString();
            break;
          }
          case 34: {
            Description = input.ReadString();
            break;
          }
          case 42: {
            Identifier = input.ReadString();
            break;
          }
          case 48: {
            Version = input.ReadUInt32();
            break;
          }
          case 56: {
            Platform = (global::Uplay.Download.Platform) input.ReadEnum();
            break;
          }
          case 64: {
            PlatformType = (global::Uplay.Download.PlatformType) input.ReadEnum();
            break;
          }
          case 72: {
            IgnoreAllExitCodes = input.ReadBool();
            break;
          }
          case 80: {
            RestartRequired = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class RegistryStringEntry : pb::IMessage<RegistryStringEntry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RegistryStringEntry> _parser = new pb::MessageParser<RegistryStringEntry>(() => new RegistryStringEntry());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RegistryStringEntry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegistryStringEntry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegistryStringEntry(RegistryStringEntry other) : this() {
      value_ = other.value_;
      language_ = other.language_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegistryStringEntry Clone() {
      return new RegistryStringEntry(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 2;
    private readonly static string LanguageDefaultValue = "";

    private string language_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_ ?? LanguageDefaultValue; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "language" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLanguage {
      get { return language_ != null; }
    }
    /// <summary>Clears the value of the "language" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLanguage() {
      language_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RegistryStringEntry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RegistryStringEntry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Value != other.Value) return false;
      if (Language != other.Language) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasValue) hash ^= Value.GetHashCode();
      if (HasLanguage) hash ^= Language.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasValue) {
        output.WriteRawTag(10);
        output.WriteString(Value);
      }
      if (HasLanguage) {
        output.WriteRawTag(18);
        output.WriteString(Language);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasValue) {
        output.WriteRawTag(10);
        output.WriteString(Value);
      }
      if (HasLanguage) {
        output.WriteRawTag(18);
        output.WriteString(Language);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (HasLanguage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RegistryStringEntry other) {
      if (other == null) {
        return;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasLanguage) {
        Language = other.Language;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Value = input.ReadString();
            break;
          }
          case 18: {
            Language = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Value = input.ReadString();
            break;
          }
          case 18: {
            Language = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class RegistryNumberEntry : pb::IMessage<RegistryNumberEntry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RegistryNumberEntry> _parser = new pb::MessageParser<RegistryNumberEntry>(() => new RegistryNumberEntry());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RegistryNumberEntry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegistryNumberEntry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegistryNumberEntry(RegistryNumberEntry other) : this() {
      _hasBits0 = other._hasBits0;
      value_ = other.value_;
      language_ = other.language_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegistryNumberEntry Clone() {
      return new RegistryNumberEntry(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private readonly static uint ValueDefaultValue = 0;

    private uint value_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Value {
      get { if ((_hasBits0 & 1) != 0) { return value_; } else { return ValueDefaultValue; } }
      set {
        _hasBits0 |= 1;
        value_ = value;
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 2;
    private readonly static string LanguageDefaultValue = "";

    private string language_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_ ?? LanguageDefaultValue; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "language" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLanguage {
      get { return language_ != null; }
    }
    /// <summary>Clears the value of the "language" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLanguage() {
      language_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RegistryNumberEntry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RegistryNumberEntry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Value != other.Value) return false;
      if (Language != other.Language) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasValue) hash ^= Value.GetHashCode();
      if (HasLanguage) hash ^= Language.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasValue) {
        output.WriteRawTag(8);
        output.WriteUInt32(Value);
      }
      if (HasLanguage) {
        output.WriteRawTag(18);
        output.WriteString(Language);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasValue) {
        output.WriteRawTag(8);
        output.WriteUInt32(Value);
      }
      if (HasLanguage) {
        output.WriteRawTag(18);
        output.WriteString(Language);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Value);
      }
      if (HasLanguage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RegistryNumberEntry other) {
      if (other == null) {
        return;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasLanguage) {
        Language = other.Language;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Value = input.ReadUInt32();
            break;
          }
          case 18: {
            Language = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Value = input.ReadUInt32();
            break;
          }
          case 18: {
            Language = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class InstallRegistry : pb::IMessage<InstallRegistry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstallRegistry> _parser = new pb::MessageParser<InstallRegistry>(() => new InstallRegistry());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InstallRegistry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallRegistry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallRegistry(InstallRegistry other) : this() {
      _hasBits0 = other._hasBits0;
      key_ = other.key_;
      type_ = other.type_;
      registryStringEntry_ = other.registryStringEntry_.Clone();
      registryNumberEntry_ = other.registryNumberEntry_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallRegistry Clone() {
      return new InstallRegistry(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private readonly static global::Uplay.Download.InstallRegistry.Types.ValueType TypeDefaultValue = global::Uplay.Download.InstallRegistry.Types.ValueType.String;

    private global::Uplay.Download.InstallRegistry.Types.ValueType type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.InstallRegistry.Types.ValueType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "registryStringEntry" field.</summary>
    public const int RegistryStringEntryFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.Download.RegistryStringEntry> _repeated_registryStringEntry_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.Download.RegistryStringEntry.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.RegistryStringEntry> registryStringEntry_ = new pbc::RepeatedField<global::Uplay.Download.RegistryStringEntry>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.RegistryStringEntry> RegistryStringEntry {
      get { return registryStringEntry_; }
    }

    /// <summary>Field number for the "registryNumberEntry" field.</summary>
    public const int RegistryNumberEntryFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Uplay.Download.RegistryNumberEntry> _repeated_registryNumberEntry_codec
        = pb::FieldCodec.ForMessage(34, global::Uplay.Download.RegistryNumberEntry.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.RegistryNumberEntry> registryNumberEntry_ = new pbc::RepeatedField<global::Uplay.Download.RegistryNumberEntry>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.RegistryNumberEntry> RegistryNumberEntry {
      get { return registryNumberEntry_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InstallRegistry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InstallRegistry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Type != other.Type) return false;
      if(!registryStringEntry_.Equals(other.registryStringEntry_)) return false;
      if(!registryNumberEntry_.Equals(other.registryNumberEntry_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      hash ^= registryStringEntry_.GetHashCode();
      hash ^= registryNumberEntry_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasType) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      registryStringEntry_.WriteTo(output, _repeated_registryStringEntry_codec);
      registryNumberEntry_.WriteTo(output, _repeated_registryNumberEntry_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasType) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      registryStringEntry_.WriteTo(ref output, _repeated_registryStringEntry_codec);
      registryNumberEntry_.WriteTo(ref output, _repeated_registryNumberEntry_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      size += registryStringEntry_.CalculateSize(_repeated_registryStringEntry_codec);
      size += registryNumberEntry_.CalculateSize(_repeated_registryNumberEntry_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InstallRegistry other) {
      if (other == null) {
        return;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      registryStringEntry_.Add(other.registryStringEntry_);
      registryNumberEntry_.Add(other.registryNumberEntry_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 16: {
            Type = (global::Uplay.Download.InstallRegistry.Types.ValueType) input.ReadEnum();
            break;
          }
          case 26: {
            registryStringEntry_.AddEntriesFrom(input, _repeated_registryStringEntry_codec);
            break;
          }
          case 34: {
            registryNumberEntry_.AddEntriesFrom(input, _repeated_registryNumberEntry_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 16: {
            Type = (global::Uplay.Download.InstallRegistry.Types.ValueType) input.ReadEnum();
            break;
          }
          case 26: {
            registryStringEntry_.AddEntriesFrom(ref input, _repeated_registryStringEntry_codec);
            break;
          }
          case 34: {
            registryNumberEntry_.AddEntriesFrom(ref input, _repeated_registryNumberEntry_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the InstallRegistry message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum ValueType {
        [pbr::OriginalName("ValueType_String")] String = 0,
        [pbr::OriginalName("ValueType_Number")] Number = 1,
      }

    }
    #endregion

  }

  public sealed partial class InstallGameExplorer : pb::IMessage<InstallGameExplorer>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstallGameExplorer> _parser = new pb::MessageParser<InstallGameExplorer>(() => new InstallGameExplorer());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InstallGameExplorer> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallGameExplorer() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallGameExplorer(InstallGameExplorer other) : this() {
      _hasBits0 = other._hasBits0;
      gdfPath_ = other.gdfPath_;
      version_ = other.version_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallGameExplorer Clone() {
      return new InstallGameExplorer(this);
    }

    /// <summary>Field number for the "gdfPath" field.</summary>
    public const int GdfPathFieldNumber = 1;
    private readonly static string GdfPathDefaultValue = "";

    private string gdfPath_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string GdfPath {
      get { return gdfPath_ ?? GdfPathDefaultValue; }
      set {
        gdfPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gdfPath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGdfPath {
      get { return gdfPath_ != null; }
    }
    /// <summary>Clears the value of the "gdfPath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGdfPath() {
      gdfPath_ = null;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private readonly static uint VersionDefaultValue = 0;

    private uint version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Version {
      get { if ((_hasBits0 & 1) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InstallGameExplorer);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InstallGameExplorer other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (GdfPath != other.GdfPath) return false;
      if (Version != other.Version) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasGdfPath) hash ^= GdfPath.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasGdfPath) {
        output.WriteRawTag(10);
        output.WriteString(GdfPath);
      }
      if (HasVersion) {
        output.WriteRawTag(16);
        output.WriteUInt32(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasGdfPath) {
        output.WriteRawTag(10);
        output.WriteString(GdfPath);
      }
      if (HasVersion) {
        output.WriteRawTag(16);
        output.WriteUInt32(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasGdfPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GdfPath);
      }
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InstallGameExplorer other) {
      if (other == null) {
        return;
      }
      if (other.HasGdfPath) {
        GdfPath = other.GdfPath;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            GdfPath = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            GdfPath = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class InstallFirewallRule : pb::IMessage<InstallFirewallRule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstallFirewallRule> _parser = new pb::MessageParser<InstallFirewallRule>(() => new InstallFirewallRule());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InstallFirewallRule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallFirewallRule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallFirewallRule(InstallFirewallRule other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      exe_ = other.exe_;
      profile_ = other.profile_;
      protocol_ = other.protocol_;
      ports_ = other.ports_;
      version_ = other.version_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallFirewallRule Clone() {
      return new InstallFirewallRule(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "exe" field.</summary>
    public const int ExeFieldNumber = 2;
    private readonly static string ExeDefaultValue = "";

    private string exe_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Exe {
      get { return exe_ ?? ExeDefaultValue; }
      set {
        exe_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "exe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExe {
      get { return exe_ != null; }
    }
    /// <summary>Clears the value of the "exe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExe() {
      exe_ = null;
    }

    /// <summary>Field number for the "profile" field.</summary>
    public const int ProfileFieldNumber = 3;
    private readonly static global::Uplay.Download.FirewallProfile ProfileDefaultValue = global::Uplay.Download.FirewallProfile.Domain;

    private global::Uplay.Download.FirewallProfile profile_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.FirewallProfile Profile {
      get { if ((_hasBits0 & 1) != 0) { return profile_; } else { return ProfileDefaultValue; } }
      set {
        _hasBits0 |= 1;
        profile_ = value;
      }
    }
    /// <summary>Gets whether the "profile" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProfile {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "profile" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProfile() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 4;
    private readonly static global::Uplay.Download.FirewallProtocol ProtocolDefaultValue = global::Uplay.Download.FirewallProtocol.Tcp;

    private global::Uplay.Download.FirewallProtocol protocol_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.FirewallProtocol Protocol {
      get { if ((_hasBits0 & 2) != 0) { return protocol_; } else { return ProtocolDefaultValue; } }
      set {
        _hasBits0 |= 2;
        protocol_ = value;
      }
    }
    /// <summary>Gets whether the "protocol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtocol {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "protocol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtocol() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 5;
    private readonly static string PortsDefaultValue = "";

    private string ports_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Ports {
      get { return ports_ ?? PortsDefaultValue; }
      set {
        ports_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ports" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPorts {
      get { return ports_ != null; }
    }
    /// <summary>Clears the value of the "ports" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPorts() {
      ports_ = null;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 6;
    private readonly static uint VersionDefaultValue = 0;

    private uint version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Version {
      get { if ((_hasBits0 & 4) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 4;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InstallFirewallRule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InstallFirewallRule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Exe != other.Exe) return false;
      if (Profile != other.Profile) return false;
      if (Protocol != other.Protocol) return false;
      if (Ports != other.Ports) return false;
      if (Version != other.Version) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasExe) hash ^= Exe.GetHashCode();
      if (HasProfile) hash ^= Profile.GetHashCode();
      if (HasProtocol) hash ^= Protocol.GetHashCode();
      if (HasPorts) hash ^= Ports.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasExe) {
        output.WriteRawTag(18);
        output.WriteString(Exe);
      }
      if (HasProfile) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Profile);
      }
      if (HasProtocol) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Protocol);
      }
      if (HasPorts) {
        output.WriteRawTag(42);
        output.WriteString(Ports);
      }
      if (HasVersion) {
        output.WriteRawTag(48);
        output.WriteUInt32(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasExe) {
        output.WriteRawTag(18);
        output.WriteString(Exe);
      }
      if (HasProfile) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Profile);
      }
      if (HasProtocol) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Protocol);
      }
      if (HasPorts) {
        output.WriteRawTag(42);
        output.WriteString(Ports);
      }
      if (HasVersion) {
        output.WriteRawTag(48);
        output.WriteUInt32(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasExe) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Exe);
      }
      if (HasProfile) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Profile);
      }
      if (HasProtocol) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Protocol);
      }
      if (HasPorts) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ports);
      }
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InstallFirewallRule other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasExe) {
        Exe = other.Exe;
      }
      if (other.HasProfile) {
        Profile = other.Profile;
      }
      if (other.HasProtocol) {
        Protocol = other.Protocol;
      }
      if (other.HasPorts) {
        Ports = other.Ports;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Exe = input.ReadString();
            break;
          }
          case 24: {
            Profile = (global::Uplay.Download.FirewallProfile) input.ReadEnum();
            break;
          }
          case 32: {
            Protocol = (global::Uplay.Download.FirewallProtocol) input.ReadEnum();
            break;
          }
          case 42: {
            Ports = input.ReadString();
            break;
          }
          case 48: {
            Version = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Exe = input.ReadString();
            break;
          }
          case 24: {
            Profile = (global::Uplay.Download.FirewallProfile) input.ReadEnum();
            break;
          }
          case 32: {
            Protocol = (global::Uplay.Download.FirewallProtocol) input.ReadEnum();
            break;
          }
          case 42: {
            Ports = input.ReadString();
            break;
          }
          case 48: {
            Version = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class InstallCompatibility : pb::IMessage<InstallCompatibility>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstallCompatibility> _parser = new pb::MessageParser<InstallCompatibility>(() => new InstallCompatibility());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InstallCompatibility> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallCompatibility() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallCompatibility(InstallCompatibility other) : this() {
      _hasBits0 = other._hasBits0;
      exe_ = other.exe_;
      options_ = other.options_;
      platform_ = other.platform_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallCompatibility Clone() {
      return new InstallCompatibility(this);
    }

    /// <summary>Field number for the "exe" field.</summary>
    public const int ExeFieldNumber = 1;
    private readonly static string ExeDefaultValue = "";

    private string exe_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Exe {
      get { return exe_ ?? ExeDefaultValue; }
      set {
        exe_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "exe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExe {
      get { return exe_ != null; }
    }
    /// <summary>Clears the value of the "exe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExe() {
      exe_ = null;
    }

    /// <summary>Field number for the "options" field.</summary>
    public const int OptionsFieldNumber = 2;
    private readonly static string OptionsDefaultValue = "";

    private string options_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Options {
      get { return options_ ?? OptionsDefaultValue; }
      set {
        options_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "options" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptions {
      get { return options_ != null; }
    }
    /// <summary>Clears the value of the "options" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptions() {
      options_ = null;
    }

    /// <summary>Field number for the "platform" field.</summary>
    public const int PlatformFieldNumber = 3;
    private readonly static global::Uplay.Download.Platform PlatformDefaultValue = global::Uplay.Download.Platform.WindowsXp;

    private global::Uplay.Download.Platform platform_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.Platform Platform {
      get { if ((_hasBits0 & 1) != 0) { return platform_; } else { return PlatformDefaultValue; } }
      set {
        _hasBits0 |= 1;
        platform_ = value;
      }
    }
    /// <summary>Gets whether the "platform" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPlatform {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "platform" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPlatform() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InstallCompatibility);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InstallCompatibility other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Exe != other.Exe) return false;
      if (Options != other.Options) return false;
      if (Platform != other.Platform) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasExe) hash ^= Exe.GetHashCode();
      if (HasOptions) hash ^= Options.GetHashCode();
      if (HasPlatform) hash ^= Platform.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasExe) {
        output.WriteRawTag(10);
        output.WriteString(Exe);
      }
      if (HasOptions) {
        output.WriteRawTag(18);
        output.WriteString(Options);
      }
      if (HasPlatform) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Platform);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasExe) {
        output.WriteRawTag(10);
        output.WriteString(Exe);
      }
      if (HasOptions) {
        output.WriteRawTag(18);
        output.WriteString(Options);
      }
      if (HasPlatform) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Platform);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasExe) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Exe);
      }
      if (HasOptions) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Options);
      }
      if (HasPlatform) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Platform);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InstallCompatibility other) {
      if (other == null) {
        return;
      }
      if (other.HasExe) {
        Exe = other.Exe;
      }
      if (other.HasOptions) {
        Options = other.Options;
      }
      if (other.HasPlatform) {
        Platform = other.Platform;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Exe = input.ReadString();
            break;
          }
          case 18: {
            Options = input.ReadString();
            break;
          }
          case 24: {
            Platform = (global::Uplay.Download.Platform) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Exe = input.ReadString();
            break;
          }
          case 18: {
            Options = input.ReadString();
            break;
          }
          case 24: {
            Platform = (global::Uplay.Download.Platform) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class UninstallRun : pb::IMessage<UninstallRun>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UninstallRun> _parser = new pb::MessageParser<UninstallRun>(() => new UninstallRun());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UninstallRun> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UninstallRun() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UninstallRun(UninstallRun other) : this() {
      _hasBits0 = other._hasBits0;
      exe_ = other.exe_;
      workingDir_ = other.workingDir_;
      arguments_ = other.arguments_;
      platform_ = other.platform_;
      platformType_ = other.platformType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UninstallRun Clone() {
      return new UninstallRun(this);
    }

    /// <summary>Field number for the "exe" field.</summary>
    public const int ExeFieldNumber = 1;
    private readonly static string ExeDefaultValue = "";

    private string exe_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Exe {
      get { return exe_ ?? ExeDefaultValue; }
      set {
        exe_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "exe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExe {
      get { return exe_ != null; }
    }
    /// <summary>Clears the value of the "exe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExe() {
      exe_ = null;
    }

    /// <summary>Field number for the "workingDir" field.</summary>
    public const int WorkingDirFieldNumber = 2;
    private readonly static string WorkingDirDefaultValue = "";

    private string workingDir_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string WorkingDir {
      get { return workingDir_ ?? WorkingDirDefaultValue; }
      set {
        workingDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "workingDir" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWorkingDir {
      get { return workingDir_ != null; }
    }
    /// <summary>Clears the value of the "workingDir" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWorkingDir() {
      workingDir_ = null;
    }

    /// <summary>Field number for the "arguments" field.</summary>
    public const int ArgumentsFieldNumber = 3;
    private readonly static string ArgumentsDefaultValue = "";

    private string arguments_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Arguments {
      get { return arguments_ ?? ArgumentsDefaultValue; }
      set {
        arguments_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "arguments" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasArguments {
      get { return arguments_ != null; }
    }
    /// <summary>Clears the value of the "arguments" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearArguments() {
      arguments_ = null;
    }

    /// <summary>Field number for the "platform" field.</summary>
    public const int PlatformFieldNumber = 5;
    private readonly static global::Uplay.Download.Platform PlatformDefaultValue = global::Uplay.Download.Platform.WindowsXp;

    private global::Uplay.Download.Platform platform_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.Platform Platform {
      get { if ((_hasBits0 & 1) != 0) { return platform_; } else { return PlatformDefaultValue; } }
      set {
        _hasBits0 |= 1;
        platform_ = value;
      }
    }
    /// <summary>Gets whether the "platform" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPlatform {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "platform" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPlatform() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "platformType" field.</summary>
    public const int PlatformTypeFieldNumber = 6;
    private readonly static global::Uplay.Download.PlatformType PlatformTypeDefaultValue = global::Uplay.Download.PlatformType.X86;

    private global::Uplay.Download.PlatformType platformType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.PlatformType PlatformType {
      get { if ((_hasBits0 & 2) != 0) { return platformType_; } else { return PlatformTypeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        platformType_ = value;
      }
    }
    /// <summary>Gets whether the "platformType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPlatformType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "platformType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPlatformType() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UninstallRun);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UninstallRun other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Exe != other.Exe) return false;
      if (WorkingDir != other.WorkingDir) return false;
      if (Arguments != other.Arguments) return false;
      if (Platform != other.Platform) return false;
      if (PlatformType != other.PlatformType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasExe) hash ^= Exe.GetHashCode();
      if (HasWorkingDir) hash ^= WorkingDir.GetHashCode();
      if (HasArguments) hash ^= Arguments.GetHashCode();
      if (HasPlatform) hash ^= Platform.GetHashCode();
      if (HasPlatformType) hash ^= PlatformType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasExe) {
        output.WriteRawTag(10);
        output.WriteString(Exe);
      }
      if (HasWorkingDir) {
        output.WriteRawTag(18);
        output.WriteString(WorkingDir);
      }
      if (HasArguments) {
        output.WriteRawTag(26);
        output.WriteString(Arguments);
      }
      if (HasPlatform) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Platform);
      }
      if (HasPlatformType) {
        output.WriteRawTag(48);
        output.WriteEnum((int) PlatformType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasExe) {
        output.WriteRawTag(10);
        output.WriteString(Exe);
      }
      if (HasWorkingDir) {
        output.WriteRawTag(18);
        output.WriteString(WorkingDir);
      }
      if (HasArguments) {
        output.WriteRawTag(26);
        output.WriteString(Arguments);
      }
      if (HasPlatform) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Platform);
      }
      if (HasPlatformType) {
        output.WriteRawTag(48);
        output.WriteEnum((int) PlatformType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasExe) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Exe);
      }
      if (HasWorkingDir) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WorkingDir);
      }
      if (HasArguments) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Arguments);
      }
      if (HasPlatform) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Platform);
      }
      if (HasPlatformType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PlatformType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UninstallRun other) {
      if (other == null) {
        return;
      }
      if (other.HasExe) {
        Exe = other.Exe;
      }
      if (other.HasWorkingDir) {
        WorkingDir = other.WorkingDir;
      }
      if (other.HasArguments) {
        Arguments = other.Arguments;
      }
      if (other.HasPlatform) {
        Platform = other.Platform;
      }
      if (other.HasPlatformType) {
        PlatformType = other.PlatformType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Exe = input.ReadString();
            break;
          }
          case 18: {
            WorkingDir = input.ReadString();
            break;
          }
          case 26: {
            Arguments = input.ReadString();
            break;
          }
          case 40: {
            Platform = (global::Uplay.Download.Platform) input.ReadEnum();
            break;
          }
          case 48: {
            PlatformType = (global::Uplay.Download.PlatformType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Exe = input.ReadString();
            break;
          }
          case 18: {
            WorkingDir = input.ReadString();
            break;
          }
          case 26: {
            Arguments = input.ReadString();
            break;
          }
          case 40: {
            Platform = (global::Uplay.Download.Platform) input.ReadEnum();
            break;
          }
          case 48: {
            PlatformType = (global::Uplay.Download.PlatformType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class UninstallRegistry : pb::IMessage<UninstallRegistry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UninstallRegistry> _parser = new pb::MessageParser<UninstallRegistry>(() => new UninstallRegistry());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UninstallRegistry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UninstallRegistry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UninstallRegistry(UninstallRegistry other) : this() {
      key_ = other.key_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UninstallRegistry Clone() {
      return new UninstallRegistry(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UninstallRegistry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UninstallRegistry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKey) hash ^= Key.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UninstallRegistry other) {
      if (other == null) {
        return;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Slice : pb::IMessage<Slice>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Slice> _parser = new pb::MessageParser<Slice>(() => new Slice());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Slice> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Slice() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Slice(Slice other) : this() {
      _hasBits0 = other._hasBits0;
      size_ = other.size_;
      downloadSize_ = other.downloadSize_;
      downloadSha1_ = other.downloadSha1_;
      fileOffset_ = other.fileOffset_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Slice Clone() {
      return new Slice(this);
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 1;
    private readonly static uint SizeDefaultValue = 0;

    private uint size_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Size {
      get { if ((_hasBits0 & 1) != 0) { return size_; } else { return SizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        size_ = value;
      }
    }
    /// <summary>Gets whether the "size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "downloadSize" field.</summary>
    public const int DownloadSizeFieldNumber = 2;
    private readonly static uint DownloadSizeDefaultValue = 0;

    private uint downloadSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint DownloadSize {
      get { if ((_hasBits0 & 2) != 0) { return downloadSize_; } else { return DownloadSizeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        downloadSize_ = value;
      }
    }
    /// <summary>Gets whether the "downloadSize" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDownloadSize {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "downloadSize" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDownloadSize() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "downloadSha1" field.</summary>
    public const int DownloadSha1FieldNumber = 3;
    private readonly static pb::ByteString DownloadSha1DefaultValue = pb::ByteString.Empty;

    private pb::ByteString downloadSha1_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString DownloadSha1 {
      get { return downloadSha1_ ?? DownloadSha1DefaultValue; }
      set {
        downloadSha1_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "downloadSha1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDownloadSha1 {
      get { return downloadSha1_ != null; }
    }
    /// <summary>Clears the value of the "downloadSha1" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDownloadSha1() {
      downloadSha1_ = null;
    }

    /// <summary>Field number for the "fileOffset" field.</summary>
    public const int FileOffsetFieldNumber = 4;
    private readonly static ulong FileOffsetDefaultValue = 0UL;

    private ulong fileOffset_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong FileOffset {
      get { if ((_hasBits0 & 4) != 0) { return fileOffset_; } else { return FileOffsetDefaultValue; } }
      set {
        _hasBits0 |= 4;
        fileOffset_ = value;
      }
    }
    /// <summary>Gets whether the "fileOffset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFileOffset {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "fileOffset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFileOffset() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Slice);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Slice other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Size != other.Size) return false;
      if (DownloadSize != other.DownloadSize) return false;
      if (DownloadSha1 != other.DownloadSha1) return false;
      if (FileOffset != other.FileOffset) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSize) hash ^= Size.GetHashCode();
      if (HasDownloadSize) hash ^= DownloadSize.GetHashCode();
      if (HasDownloadSha1) hash ^= DownloadSha1.GetHashCode();
      if (HasFileOffset) hash ^= FileOffset.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSize) {
        output.WriteRawTag(8);
        output.WriteUInt32(Size);
      }
      if (HasDownloadSize) {
        output.WriteRawTag(16);
        output.WriteUInt32(DownloadSize);
      }
      if (HasDownloadSha1) {
        output.WriteRawTag(26);
        output.WriteBytes(DownloadSha1);
      }
      if (HasFileOffset) {
        output.WriteRawTag(32);
        output.WriteUInt64(FileOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSize) {
        output.WriteRawTag(8);
        output.WriteUInt32(Size);
      }
      if (HasDownloadSize) {
        output.WriteRawTag(16);
        output.WriteUInt32(DownloadSize);
      }
      if (HasDownloadSha1) {
        output.WriteRawTag(26);
        output.WriteBytes(DownloadSha1);
      }
      if (HasFileOffset) {
        output.WriteRawTag(32);
        output.WriteUInt64(FileOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Size);
      }
      if (HasDownloadSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DownloadSize);
      }
      if (HasDownloadSha1) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DownloadSha1);
      }
      if (HasFileOffset) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(FileOffset);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Slice other) {
      if (other == null) {
        return;
      }
      if (other.HasSize) {
        Size = other.Size;
      }
      if (other.HasDownloadSize) {
        DownloadSize = other.DownloadSize;
      }
      if (other.HasDownloadSha1) {
        DownloadSha1 = other.DownloadSha1;
      }
      if (other.HasFileOffset) {
        FileOffset = other.FileOffset;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Size = input.ReadUInt32();
            break;
          }
          case 16: {
            DownloadSize = input.ReadUInt32();
            break;
          }
          case 26: {
            DownloadSha1 = input.ReadBytes();
            break;
          }
          case 32: {
            FileOffset = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Size = input.ReadUInt32();
            break;
          }
          case 16: {
            DownloadSize = input.ReadUInt32();
            break;
          }
          case 26: {
            DownloadSha1 = input.ReadBytes();
            break;
          }
          case 32: {
            FileOffset = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class File : pb::IMessage<File>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<File> _parser = new pb::MessageParser<File>(() => new File());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<File> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public File() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public File(File other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      size_ = other.size_;
      isDir_ = other.isDir_;
      slices_ = other.slices_.Clone();
      version_ = other.version_;
      paddedSize_ = other.paddedSize_;
      sliceList_ = other.sliceList_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public File Clone() {
      return new File(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 2;
    private readonly static ulong SizeDefaultValue = 0UL;

    private ulong size_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Size {
      get { if ((_hasBits0 & 1) != 0) { return size_; } else { return SizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        size_ = value;
      }
    }
    /// <summary>Gets whether the "size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "isDir" field.</summary>
    public const int IsDirFieldNumber = 3;
    private readonly static bool IsDirDefaultValue = false;

    private bool isDir_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsDir {
      get { if ((_hasBits0 & 2) != 0) { return isDir_; } else { return IsDirDefaultValue; } }
      set {
        _hasBits0 |= 2;
        isDir_ = value;
      }
    }
    /// <summary>Gets whether the "isDir" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsDir {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "isDir" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsDir() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "slices" field.</summary>
    public const int SlicesFieldNumber = 4;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_slices_codec
        = pb::FieldCodec.ForBytes(34);
    private readonly pbc::RepeatedField<pb::ByteString> slices_ = new pbc::RepeatedField<pb::ByteString>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<pb::ByteString> Slices {
      get { return slices_; }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 5;
    private readonly static uint VersionDefaultValue = 0;

    private uint version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Version {
      get { if ((_hasBits0 & 4) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 4;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "paddedSize" field.</summary>
    public const int PaddedSizeFieldNumber = 6;
    private readonly static ulong PaddedSizeDefaultValue = 0UL;

    private ulong paddedSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong PaddedSize {
      get { if ((_hasBits0 & 8) != 0) { return paddedSize_; } else { return PaddedSizeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        paddedSize_ = value;
      }
    }
    /// <summary>Gets whether the "paddedSize" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPaddedSize {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "paddedSize" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPaddedSize() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "sliceList" field.</summary>
    public const int SliceListFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Uplay.Download.Slice> _repeated_sliceList_codec
        = pb::FieldCodec.ForMessage(58, global::Uplay.Download.Slice.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.Slice> sliceList_ = new pbc::RepeatedField<global::Uplay.Download.Slice>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.Slice> SliceList {
      get { return sliceList_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as File);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(File other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Size != other.Size) return false;
      if (IsDir != other.IsDir) return false;
      if(!slices_.Equals(other.slices_)) return false;
      if (Version != other.Version) return false;
      if (PaddedSize != other.PaddedSize) return false;
      if(!sliceList_.Equals(other.sliceList_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasSize) hash ^= Size.GetHashCode();
      if (HasIsDir) hash ^= IsDir.GetHashCode();
      hash ^= slices_.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      if (HasPaddedSize) hash ^= PaddedSize.GetHashCode();
      hash ^= sliceList_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt64(Size);
      }
      if (HasIsDir) {
        output.WriteRawTag(24);
        output.WriteBool(IsDir);
      }
      slices_.WriteTo(output, _repeated_slices_codec);
      if (HasVersion) {
        output.WriteRawTag(40);
        output.WriteUInt32(Version);
      }
      if (HasPaddedSize) {
        output.WriteRawTag(48);
        output.WriteUInt64(PaddedSize);
      }
      sliceList_.WriteTo(output, _repeated_sliceList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt64(Size);
      }
      if (HasIsDir) {
        output.WriteRawTag(24);
        output.WriteBool(IsDir);
      }
      slices_.WriteTo(ref output, _repeated_slices_codec);
      if (HasVersion) {
        output.WriteRawTag(40);
        output.WriteUInt32(Version);
      }
      if (HasPaddedSize) {
        output.WriteRawTag(48);
        output.WriteUInt64(PaddedSize);
      }
      sliceList_.WriteTo(ref output, _repeated_sliceList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Size);
      }
      if (HasIsDir) {
        size += 1 + 1;
      }
      size += slices_.CalculateSize(_repeated_slices_codec);
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
      }
      if (HasPaddedSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(PaddedSize);
      }
      size += sliceList_.CalculateSize(_repeated_sliceList_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(File other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasSize) {
        Size = other.Size;
      }
      if (other.HasIsDir) {
        IsDir = other.IsDir;
      }
      slices_.Add(other.slices_);
      if (other.HasVersion) {
        Version = other.Version;
      }
      if (other.HasPaddedSize) {
        PaddedSize = other.PaddedSize;
      }
      sliceList_.Add(other.sliceList_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Size = input.ReadUInt64();
            break;
          }
          case 24: {
            IsDir = input.ReadBool();
            break;
          }
          case 34: {
            slices_.AddEntriesFrom(input, _repeated_slices_codec);
            break;
          }
          case 40: {
            Version = input.ReadUInt32();
            break;
          }
          case 48: {
            PaddedSize = input.ReadUInt64();
            break;
          }
          case 58: {
            sliceList_.AddEntriesFrom(input, _repeated_sliceList_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Size = input.ReadUInt64();
            break;
          }
          case 24: {
            IsDir = input.ReadBool();
            break;
          }
          case 34: {
            slices_.AddEntriesFrom(ref input, _repeated_slices_codec);
            break;
          }
          case 40: {
            Version = input.ReadUInt32();
            break;
          }
          case 48: {
            PaddedSize = input.ReadUInt64();
            break;
          }
          case 58: {
            sliceList_.AddEntriesFrom(ref input, _repeated_sliceList_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Chunk : pb::IMessage<Chunk>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Chunk> _parser = new pb::MessageParser<Chunk>(() => new Chunk());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Chunk> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Chunk() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Chunk(Chunk other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      type_ = other.type_;
      files_ = other.files_.Clone();
      uplayId_ = other.uplayId_;
      language_ = other.language_;
      disc_ = other.disc_;
      tags_ = other.tags_;
      uplayIds_ = other.uplayIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Chunk Clone() {
      return new Chunk(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static uint IdDefaultValue = 0;

    private uint id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private readonly static global::Uplay.Download.Chunk.Types.ChunkType TypeDefaultValue = global::Uplay.Download.Chunk.Types.ChunkType.Required;

    private global::Uplay.Download.Chunk.Types.ChunkType type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.Chunk.Types.ChunkType Type {
      get { if ((_hasBits0 & 2) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "files" field.</summary>
    public const int FilesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.Download.File> _repeated_files_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.Download.File.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.File> files_ = new pbc::RepeatedField<global::Uplay.Download.File>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.File> Files {
      get { return files_; }
    }

    /// <summary>Field number for the "uplayId" field.</summary>
    public const int UplayIdFieldNumber = 4;
    private readonly static uint UplayIdDefaultValue = 0;

    private uint uplayId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint UplayId {
      get { if ((_hasBits0 & 4) != 0) { return uplayId_; } else { return UplayIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        uplayId_ = value;
      }
    }
    /// <summary>Gets whether the "uplayId" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUplayId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "uplayId" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUplayId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 5;
    private readonly static string LanguageDefaultValue = "";

    private string language_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_ ?? LanguageDefaultValue; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "language" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLanguage {
      get { return language_ != null; }
    }
    /// <summary>Clears the value of the "language" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLanguage() {
      language_ = null;
    }

    /// <summary>Field number for the "disc" field.</summary>
    public const int DiscFieldNumber = 6;
    private readonly static string DiscDefaultValue = "";

    private string disc_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Disc {
      get { return disc_ ?? DiscDefaultValue; }
      set {
        disc_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "disc" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDisc {
      get { return disc_ != null; }
    }
    /// <summary>Clears the value of the "disc" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDisc() {
      disc_ = null;
    }

    /// <summary>Field number for the "tags" field.</summary>
    public const int TagsFieldNumber = 7;
    private readonly static string TagsDefaultValue = "";

    private string tags_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Tags {
      get { return tags_ ?? TagsDefaultValue; }
      set {
        tags_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "tags" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTags {
      get { return tags_ != null; }
    }
    /// <summary>Clears the value of the "tags" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTags() {
      tags_ = null;
    }

    /// <summary>Field number for the "uplayIds" field.</summary>
    public const int UplayIdsFieldNumber = 8;
    private static readonly pb::FieldCodec<uint> _repeated_uplayIds_codec
        = pb::FieldCodec.ForUInt32(64);
    private readonly pbc::RepeatedField<uint> uplayIds_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> UplayIds {
      get { return uplayIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Chunk);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Chunk other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Type != other.Type) return false;
      if(!files_.Equals(other.files_)) return false;
      if (UplayId != other.UplayId) return false;
      if (Language != other.Language) return false;
      if (Disc != other.Disc) return false;
      if (Tags != other.Tags) return false;
      if(!uplayIds_.Equals(other.uplayIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      hash ^= files_.GetHashCode();
      if (HasUplayId) hash ^= UplayId.GetHashCode();
      if (HasLanguage) hash ^= Language.GetHashCode();
      if (HasDisc) hash ^= Disc.GetHashCode();
      if (HasTags) hash ^= Tags.GetHashCode();
      hash ^= uplayIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasType) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      files_.WriteTo(output, _repeated_files_codec);
      if (HasUplayId) {
        output.WriteRawTag(32);
        output.WriteUInt32(UplayId);
      }
      if (HasLanguage) {
        output.WriteRawTag(42);
        output.WriteString(Language);
      }
      if (HasDisc) {
        output.WriteRawTag(50);
        output.WriteString(Disc);
      }
      if (HasTags) {
        output.WriteRawTag(58);
        output.WriteString(Tags);
      }
      uplayIds_.WriteTo(output, _repeated_uplayIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasType) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      files_.WriteTo(ref output, _repeated_files_codec);
      if (HasUplayId) {
        output.WriteRawTag(32);
        output.WriteUInt32(UplayId);
      }
      if (HasLanguage) {
        output.WriteRawTag(42);
        output.WriteString(Language);
      }
      if (HasDisc) {
        output.WriteRawTag(50);
        output.WriteString(Disc);
      }
      if (HasTags) {
        output.WriteRawTag(58);
        output.WriteString(Tags);
      }
      uplayIds_.WriteTo(ref output, _repeated_uplayIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      size += files_.CalculateSize(_repeated_files_codec);
      if (HasUplayId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UplayId);
      }
      if (HasLanguage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (HasDisc) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Disc);
      }
      if (HasTags) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Tags);
      }
      size += uplayIds_.CalculateSize(_repeated_uplayIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Chunk other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      files_.Add(other.files_);
      if (other.HasUplayId) {
        UplayId = other.UplayId;
      }
      if (other.HasLanguage) {
        Language = other.Language;
      }
      if (other.HasDisc) {
        Disc = other.Disc;
      }
      if (other.HasTags) {
        Tags = other.Tags;
      }
      uplayIds_.Add(other.uplayIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Type = (global::Uplay.Download.Chunk.Types.ChunkType) input.ReadEnum();
            break;
          }
          case 26: {
            files_.AddEntriesFrom(input, _repeated_files_codec);
            break;
          }
          case 32: {
            UplayId = input.ReadUInt32();
            break;
          }
          case 42: {
            Language = input.ReadString();
            break;
          }
          case 50: {
            Disc = input.ReadString();
            break;
          }
          case 58: {
            Tags = input.ReadString();
            break;
          }
          case 66:
          case 64: {
            uplayIds_.AddEntriesFrom(input, _repeated_uplayIds_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Type = (global::Uplay.Download.Chunk.Types.ChunkType) input.ReadEnum();
            break;
          }
          case 26: {
            files_.AddEntriesFrom(ref input, _repeated_files_codec);
            break;
          }
          case 32: {
            UplayId = input.ReadUInt32();
            break;
          }
          case 42: {
            Language = input.ReadString();
            break;
          }
          case 50: {
            Disc = input.ReadString();
            break;
          }
          case 58: {
            Tags = input.ReadString();
            break;
          }
          case 66:
          case 64: {
            uplayIds_.AddEntriesFrom(ref input, _repeated_uplayIds_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Chunk message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum ChunkType {
        [pbr::OriginalName("ChunkType_Required")] Required = 0,
        [pbr::OriginalName("ChunkType_Optional")] Optional = 1,
      }

    }
    #endregion

  }

  public sealed partial class MetaDataChunk : pb::IMessage<MetaDataChunk>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MetaDataChunk> _parser = new pb::MessageParser<MetaDataChunk>(() => new MetaDataChunk());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MetaDataChunk> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MetaDataChunk() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MetaDataChunk(MetaDataChunk other) : this() {
      _hasBits0 = other._hasBits0;
      uplayId_ = other.uplayId_;
      language_ = other.language_;
      bytesOnDisk_ = other.bytesOnDisk_;
      paddedBytesOnDisk_ = other.paddedBytesOnDisk_;
      uplayIds_ = other.uplayIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MetaDataChunk Clone() {
      return new MetaDataChunk(this);
    }

    /// <summary>Field number for the "uplayId" field.</summary>
    public const int UplayIdFieldNumber = 1;
    private readonly static uint UplayIdDefaultValue = 0;

    private uint uplayId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint UplayId {
      get { if ((_hasBits0 & 1) != 0) { return uplayId_; } else { return UplayIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        uplayId_ = value;
      }
    }
    /// <summary>Gets whether the "uplayId" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUplayId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "uplayId" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUplayId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 2;
    private readonly static string LanguageDefaultValue = "";

    private string language_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_ ?? LanguageDefaultValue; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "language" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLanguage {
      get { return language_ != null; }
    }
    /// <summary>Clears the value of the "language" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLanguage() {
      language_ = null;
    }

    /// <summary>Field number for the "bytesOnDisk" field.</summary>
    public const int BytesOnDiskFieldNumber = 3;
    private readonly static ulong BytesOnDiskDefaultValue = 0UL;

    private ulong bytesOnDisk_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong BytesOnDisk {
      get { if ((_hasBits0 & 2) != 0) { return bytesOnDisk_; } else { return BytesOnDiskDefaultValue; } }
      set {
        _hasBits0 |= 2;
        bytesOnDisk_ = value;
      }
    }
    /// <summary>Gets whether the "bytesOnDisk" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBytesOnDisk {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "bytesOnDisk" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBytesOnDisk() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "paddedBytesOnDisk" field.</summary>
    public const int PaddedBytesOnDiskFieldNumber = 4;
    private readonly static ulong PaddedBytesOnDiskDefaultValue = 0UL;

    private ulong paddedBytesOnDisk_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong PaddedBytesOnDisk {
      get { if ((_hasBits0 & 4) != 0) { return paddedBytesOnDisk_; } else { return PaddedBytesOnDiskDefaultValue; } }
      set {
        _hasBits0 |= 4;
        paddedBytesOnDisk_ = value;
      }
    }
    /// <summary>Gets whether the "paddedBytesOnDisk" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPaddedBytesOnDisk {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "paddedBytesOnDisk" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPaddedBytesOnDisk() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "uplayIds" field.</summary>
    public const int UplayIdsFieldNumber = 5;
    private static readonly pb::FieldCodec<uint> _repeated_uplayIds_codec
        = pb::FieldCodec.ForUInt32(40);
    private readonly pbc::RepeatedField<uint> uplayIds_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> UplayIds {
      get { return uplayIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MetaDataChunk);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MetaDataChunk other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (UplayId != other.UplayId) return false;
      if (Language != other.Language) return false;
      if (BytesOnDisk != other.BytesOnDisk) return false;
      if (PaddedBytesOnDisk != other.PaddedBytesOnDisk) return false;
      if(!uplayIds_.Equals(other.uplayIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasUplayId) hash ^= UplayId.GetHashCode();
      if (HasLanguage) hash ^= Language.GetHashCode();
      if (HasBytesOnDisk) hash ^= BytesOnDisk.GetHashCode();
      if (HasPaddedBytesOnDisk) hash ^= PaddedBytesOnDisk.GetHashCode();
      hash ^= uplayIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasUplayId) {
        output.WriteRawTag(8);
        output.WriteUInt32(UplayId);
      }
      if (HasLanguage) {
        output.WriteRawTag(18);
        output.WriteString(Language);
      }
      if (HasBytesOnDisk) {
        output.WriteRawTag(24);
        output.WriteUInt64(BytesOnDisk);
      }
      if (HasPaddedBytesOnDisk) {
        output.WriteRawTag(32);
        output.WriteUInt64(PaddedBytesOnDisk);
      }
      uplayIds_.WriteTo(output, _repeated_uplayIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasUplayId) {
        output.WriteRawTag(8);
        output.WriteUInt32(UplayId);
      }
      if (HasLanguage) {
        output.WriteRawTag(18);
        output.WriteString(Language);
      }
      if (HasBytesOnDisk) {
        output.WriteRawTag(24);
        output.WriteUInt64(BytesOnDisk);
      }
      if (HasPaddedBytesOnDisk) {
        output.WriteRawTag(32);
        output.WriteUInt64(PaddedBytesOnDisk);
      }
      uplayIds_.WriteTo(ref output, _repeated_uplayIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasUplayId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UplayId);
      }
      if (HasLanguage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (HasBytesOnDisk) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(BytesOnDisk);
      }
      if (HasPaddedBytesOnDisk) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(PaddedBytesOnDisk);
      }
      size += uplayIds_.CalculateSize(_repeated_uplayIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MetaDataChunk other) {
      if (other == null) {
        return;
      }
      if (other.HasUplayId) {
        UplayId = other.UplayId;
      }
      if (other.HasLanguage) {
        Language = other.Language;
      }
      if (other.HasBytesOnDisk) {
        BytesOnDisk = other.BytesOnDisk;
      }
      if (other.HasPaddedBytesOnDisk) {
        PaddedBytesOnDisk = other.PaddedBytesOnDisk;
      }
      uplayIds_.Add(other.uplayIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            UplayId = input.ReadUInt32();
            break;
          }
          case 18: {
            Language = input.ReadString();
            break;
          }
          case 24: {
            BytesOnDisk = input.ReadUInt64();
            break;
          }
          case 32: {
            PaddedBytesOnDisk = input.ReadUInt64();
            break;
          }
          case 42:
          case 40: {
            uplayIds_.AddEntriesFrom(input, _repeated_uplayIds_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            UplayId = input.ReadUInt32();
            break;
          }
          case 18: {
            Language = input.ReadString();
            break;
          }
          case 24: {
            BytesOnDisk = input.ReadUInt64();
            break;
          }
          case 32: {
            PaddedBytesOnDisk = input.ReadUInt64();
            break;
          }
          case 42:
          case 40: {
            uplayIds_.AddEntriesFrom(ref input, _repeated_uplayIds_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class TextFileEntry : pb::IMessage<TextFileEntry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TextFileEntry> _parser = new pb::MessageParser<TextFileEntry>(() => new TextFileEntry());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TextFileEntry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFileEntry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFileEntry(TextFileEntry other) : this() {
      fileName_ = other.fileName_;
      locale_ = other.locale_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFileEntry Clone() {
      return new TextFileEntry(this);
    }

    /// <summary>Field number for the "fileName" field.</summary>
    public const int FileNameFieldNumber = 1;
    private readonly static string FileNameDefaultValue = "";

    private string fileName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FileName {
      get { return fileName_ ?? FileNameDefaultValue; }
      set {
        fileName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fileName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFileName {
      get { return fileName_ != null; }
    }
    /// <summary>Clears the value of the "fileName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFileName() {
      fileName_ = null;
    }

    /// <summary>Field number for the "locale" field.</summary>
    public const int LocaleFieldNumber = 2;
    private readonly static string LocaleDefaultValue = "";

    private string locale_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Locale {
      get { return locale_ ?? LocaleDefaultValue; }
      set {
        locale_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "locale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLocale {
      get { return locale_ != null; }
    }
    /// <summary>Clears the value of the "locale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLocale() {
      locale_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TextFileEntry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TextFileEntry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FileName != other.FileName) return false;
      if (Locale != other.Locale) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasFileName) hash ^= FileName.GetHashCode();
      if (HasLocale) hash ^= Locale.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasFileName) {
        output.WriteRawTag(10);
        output.WriteString(FileName);
      }
      if (HasLocale) {
        output.WriteRawTag(18);
        output.WriteString(Locale);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasFileName) {
        output.WriteRawTag(10);
        output.WriteString(FileName);
      }
      if (HasLocale) {
        output.WriteRawTag(18);
        output.WriteString(Locale);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasFileName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FileName);
      }
      if (HasLocale) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Locale);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TextFileEntry other) {
      if (other == null) {
        return;
      }
      if (other.HasFileName) {
        FileName = other.FileName;
      }
      if (other.HasLocale) {
        Locale = other.Locale;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            FileName = input.ReadString();
            break;
          }
          case 18: {
            Locale = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            FileName = input.ReadString();
            break;
          }
          case 18: {
            Locale = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class TextFileList : pb::IMessage<TextFileList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TextFileList> _parser = new pb::MessageParser<TextFileList>(() => new TextFileList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TextFileList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFileList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFileList(TextFileList other) : this() {
      rootPath_ = other.rootPath_;
      files_ = other.files_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFileList Clone() {
      return new TextFileList(this);
    }

    /// <summary>Field number for the "rootPath" field.</summary>
    public const int RootPathFieldNumber = 1;
    private readonly static string RootPathDefaultValue = "";

    private string rootPath_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RootPath {
      get { return rootPath_ ?? RootPathDefaultValue; }
      set {
        rootPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "rootPath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRootPath {
      get { return rootPath_ != null; }
    }
    /// <summary>Clears the value of the "rootPath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRootPath() {
      rootPath_ = null;
    }

    /// <summary>Field number for the "files" field.</summary>
    public const int FilesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Uplay.Download.TextFileEntry> _repeated_files_codec
        = pb::FieldCodec.ForMessage(18, global::Uplay.Download.TextFileEntry.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.TextFileEntry> files_ = new pbc::RepeatedField<global::Uplay.Download.TextFileEntry>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.TextFileEntry> Files {
      get { return files_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TextFileList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TextFileList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RootPath != other.RootPath) return false;
      if(!files_.Equals(other.files_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRootPath) hash ^= RootPath.GetHashCode();
      hash ^= files_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRootPath) {
        output.WriteRawTag(10);
        output.WriteString(RootPath);
      }
      files_.WriteTo(output, _repeated_files_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRootPath) {
        output.WriteRawTag(10);
        output.WriteString(RootPath);
      }
      files_.WriteTo(ref output, _repeated_files_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasRootPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RootPath);
      }
      size += files_.CalculateSize(_repeated_files_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TextFileList other) {
      if (other == null) {
        return;
      }
      if (other.HasRootPath) {
        RootPath = other.RootPath;
      }
      files_.Add(other.files_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RootPath = input.ReadString();
            break;
          }
          case 18: {
            files_.AddEntriesFrom(input, _repeated_files_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RootPath = input.ReadString();
            break;
          }
          case 18: {
            files_.AddEntriesFrom(ref input, _repeated_files_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Language : pb::IMessage<Language>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Language> _parser = new pb::MessageParser<Language>(() => new Language());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Language> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Language() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Language(Language other) : this() {
      code_ = other.code_;
      uplayIds_ = other.uplayIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Language Clone() {
      return new Language(this);
    }

    /// <summary>Field number for the "code" field.</summary>
    public const int CodeFieldNumber = 1;
    private readonly static string CodeDefaultValue = "";

    private string code_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Code {
      get { return code_ ?? CodeDefaultValue; }
      set {
        code_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCode {
      get { return code_ != null; }
    }
    /// <summary>Clears the value of the "code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCode() {
      code_ = null;
    }

    /// <summary>Field number for the "uplayIds" field.</summary>
    public const int UplayIdsFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_uplayIds_codec
        = pb::FieldCodec.ForUInt32(16);
    private readonly pbc::RepeatedField<uint> uplayIds_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> UplayIds {
      get { return uplayIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Language);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Language other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Code != other.Code) return false;
      if(!uplayIds_.Equals(other.uplayIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCode) hash ^= Code.GetHashCode();
      hash ^= uplayIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasCode) {
        output.WriteRawTag(10);
        output.WriteString(Code);
      }
      uplayIds_.WriteTo(output, _repeated_uplayIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCode) {
        output.WriteRawTag(10);
        output.WriteString(Code);
      }
      uplayIds_.WriteTo(ref output, _repeated_uplayIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasCode) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Code);
      }
      size += uplayIds_.CalculateSize(_repeated_uplayIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Language other) {
      if (other == null) {
        return;
      }
      if (other.HasCode) {
        Code = other.Code;
      }
      uplayIds_.Add(other.uplayIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Code = input.ReadString();
            break;
          }
          case 18:
          case 16: {
            uplayIds_.AddEntriesFrom(input, _repeated_uplayIds_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Code = input.ReadString();
            break;
          }
          case 18:
          case 16: {
            uplayIds_.AddEntriesFrom(ref input, _repeated_uplayIds_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class SlicerConfig : pb::IMessage<SlicerConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SlicerConfig> _parser = new pb::MessageParser<SlicerConfig>(() => new SlicerConfig());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SlicerConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SlicerConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SlicerConfig(SlicerConfig other) : this() {
      _hasBits0 = other._hasBits0;
      slicerType_ = other.slicerType_;
      minSliceSizeBytes_ = other.minSliceSizeBytes_;
      expectedSliceSizeBytes_ = other.expectedSliceSizeBytes_;
      maxSliceSizeBytes_ = other.maxSliceSizeBytes_;
      configVersion_ = other.configVersion_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SlicerConfig Clone() {
      return new SlicerConfig(this);
    }

    /// <summary>Field number for the "slicerType" field.</summary>
    public const int SlicerTypeFieldNumber = 1;
    private readonly static global::Uplay.Download.SlicerConfig.Types.SlicerType SlicerTypeDefaultValue = global::Uplay.Download.SlicerConfig.Types.SlicerType.Fsc;

    private global::Uplay.Download.SlicerConfig.Types.SlicerType slicerType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.SlicerConfig.Types.SlicerType SlicerType {
      get { if ((_hasBits0 & 1) != 0) { return slicerType_; } else { return SlicerTypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        slicerType_ = value;
      }
    }
    /// <summary>Gets whether the "slicerType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSlicerType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "slicerType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSlicerType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "minSliceSizeBytes" field.</summary>
    public const int MinSliceSizeBytesFieldNumber = 2;
    private readonly static uint MinSliceSizeBytesDefaultValue = 0;

    private uint minSliceSizeBytes_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MinSliceSizeBytes {
      get { if ((_hasBits0 & 2) != 0) { return minSliceSizeBytes_; } else { return MinSliceSizeBytesDefaultValue; } }
      set {
        _hasBits0 |= 2;
        minSliceSizeBytes_ = value;
      }
    }
    /// <summary>Gets whether the "minSliceSizeBytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinSliceSizeBytes {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "minSliceSizeBytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinSliceSizeBytes() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "expectedSliceSizeBytes" field.</summary>
    public const int ExpectedSliceSizeBytesFieldNumber = 3;
    private readonly static uint ExpectedSliceSizeBytesDefaultValue = 0;

    private uint expectedSliceSizeBytes_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ExpectedSliceSizeBytes {
      get { if ((_hasBits0 & 4) != 0) { return expectedSliceSizeBytes_; } else { return ExpectedSliceSizeBytesDefaultValue; } }
      set {
        _hasBits0 |= 4;
        expectedSliceSizeBytes_ = value;
      }
    }
    /// <summary>Gets whether the "expectedSliceSizeBytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExpectedSliceSizeBytes {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "expectedSliceSizeBytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExpectedSliceSizeBytes() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "maxSliceSizeBytes" field.</summary>
    public const int MaxSliceSizeBytesFieldNumber = 4;
    private readonly static uint MaxSliceSizeBytesDefaultValue = 0;

    private uint maxSliceSizeBytes_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MaxSliceSizeBytes {
      get { if ((_hasBits0 & 8) != 0) { return maxSliceSizeBytes_; } else { return MaxSliceSizeBytesDefaultValue; } }
      set {
        _hasBits0 |= 8;
        maxSliceSizeBytes_ = value;
      }
    }
    /// <summary>Gets whether the "maxSliceSizeBytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxSliceSizeBytes {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "maxSliceSizeBytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxSliceSizeBytes() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "configVersion" field.</summary>
    public const int ConfigVersionFieldNumber = 5;
    private readonly static uint ConfigVersionDefaultValue = 0;

    private uint configVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ConfigVersion {
      get { if ((_hasBits0 & 16) != 0) { return configVersion_; } else { return ConfigVersionDefaultValue; } }
      set {
        _hasBits0 |= 16;
        configVersion_ = value;
      }
    }
    /// <summary>Gets whether the "configVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConfigVersion {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "configVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConfigVersion() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SlicerConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SlicerConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SlicerType != other.SlicerType) return false;
      if (MinSliceSizeBytes != other.MinSliceSizeBytes) return false;
      if (ExpectedSliceSizeBytes != other.ExpectedSliceSizeBytes) return false;
      if (MaxSliceSizeBytes != other.MaxSliceSizeBytes) return false;
      if (ConfigVersion != other.ConfigVersion) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSlicerType) hash ^= SlicerType.GetHashCode();
      if (HasMinSliceSizeBytes) hash ^= MinSliceSizeBytes.GetHashCode();
      if (HasExpectedSliceSizeBytes) hash ^= ExpectedSliceSizeBytes.GetHashCode();
      if (HasMaxSliceSizeBytes) hash ^= MaxSliceSizeBytes.GetHashCode();
      if (HasConfigVersion) hash ^= ConfigVersion.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSlicerType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) SlicerType);
      }
      if (HasMinSliceSizeBytes) {
        output.WriteRawTag(16);
        output.WriteUInt32(MinSliceSizeBytes);
      }
      if (HasExpectedSliceSizeBytes) {
        output.WriteRawTag(24);
        output.WriteUInt32(ExpectedSliceSizeBytes);
      }
      if (HasMaxSliceSizeBytes) {
        output.WriteRawTag(32);
        output.WriteUInt32(MaxSliceSizeBytes);
      }
      if (HasConfigVersion) {
        output.WriteRawTag(40);
        output.WriteUInt32(ConfigVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSlicerType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) SlicerType);
      }
      if (HasMinSliceSizeBytes) {
        output.WriteRawTag(16);
        output.WriteUInt32(MinSliceSizeBytes);
      }
      if (HasExpectedSliceSizeBytes) {
        output.WriteRawTag(24);
        output.WriteUInt32(ExpectedSliceSizeBytes);
      }
      if (HasMaxSliceSizeBytes) {
        output.WriteRawTag(32);
        output.WriteUInt32(MaxSliceSizeBytes);
      }
      if (HasConfigVersion) {
        output.WriteRawTag(40);
        output.WriteUInt32(ConfigVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSlicerType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SlicerType);
      }
      if (HasMinSliceSizeBytes) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinSliceSizeBytes);
      }
      if (HasExpectedSliceSizeBytes) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExpectedSliceSizeBytes);
      }
      if (HasMaxSliceSizeBytes) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxSliceSizeBytes);
      }
      if (HasConfigVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ConfigVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SlicerConfig other) {
      if (other == null) {
        return;
      }
      if (other.HasSlicerType) {
        SlicerType = other.SlicerType;
      }
      if (other.HasMinSliceSizeBytes) {
        MinSliceSizeBytes = other.MinSliceSizeBytes;
      }
      if (other.HasExpectedSliceSizeBytes) {
        ExpectedSliceSizeBytes = other.ExpectedSliceSizeBytes;
      }
      if (other.HasMaxSliceSizeBytes) {
        MaxSliceSizeBytes = other.MaxSliceSizeBytes;
      }
      if (other.HasConfigVersion) {
        ConfigVersion = other.ConfigVersion;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SlicerType = (global::Uplay.Download.SlicerConfig.Types.SlicerType) input.ReadEnum();
            break;
          }
          case 16: {
            MinSliceSizeBytes = input.ReadUInt32();
            break;
          }
          case 24: {
            ExpectedSliceSizeBytes = input.ReadUInt32();
            break;
          }
          case 32: {
            MaxSliceSizeBytes = input.ReadUInt32();
            break;
          }
          case 40: {
            ConfigVersion = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            SlicerType = (global::Uplay.Download.SlicerConfig.Types.SlicerType) input.ReadEnum();
            break;
          }
          case 16: {
            MinSliceSizeBytes = input.ReadUInt32();
            break;
          }
          case 24: {
            ExpectedSliceSizeBytes = input.ReadUInt32();
            break;
          }
          case 32: {
            MaxSliceSizeBytes = input.ReadUInt32();
            break;
          }
          case 40: {
            ConfigVersion = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SlicerConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum SlicerType {
        [pbr::OriginalName("Fsc")] Fsc = 1,
        [pbr::OriginalName("FastCdc")] FastCdc = 2,
      }

    }
    #endregion

  }

  public sealed partial class Manifest : pb::IMessage<Manifest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Manifest> _parser = new pb::MessageParser<Manifest>(() => new Manifest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Manifest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Manifest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Manifest(Manifest other) : this() {
      _hasBits0 = other._hasBits0;
      licenses_ = other.licenses_.Clone();
      installRuns_ = other.installRuns_.Clone();
      installRegistry_ = other.installRegistry_.Clone();
      uninstallRuns_ = other.uninstallRuns_.Clone();
      uninstallRegistry_ = other.uninstallRegistry_.Clone();
      chunks_ = other.chunks_.Clone();
      chunksVersion_ = other.chunksVersion_;
      sliceSizeDeprecated_ = other.sliceSizeDeprecated_;
      installGameExplorer_ = other.installGameExplorer_.Clone();
      installFirewallRules_ = other.installFirewallRules_.Clone();
      installCompatibility_ = other.installCompatibility_.Clone();
      legacyInstaller_ = other.legacyInstaller_;
      deprecatedLanguages_ = other.deprecatedLanguages_.Clone();
      isEncryptedDeprecated_ = other.isEncryptedDeprecated_;
      paddedSliceSizeDeprecated_ = other.paddedSliceSizeDeprecated_;
      patchRequired_ = other.patchRequired_;
      isCompressed_ = other.isCompressed_;
      readmeFiles_ = other.readmeFiles_ != null ? other.readmeFiles_.Clone() : null;
      manualFiles_ = other.manualFiles_ != null ? other.manualFiles_.Clone() : null;
      gameVersion_ = other.gameVersion_;
      compressionMethod_ = other.compressionMethod_;
      version_ = other.version_;
      languages_ = other.languages_.Clone();
      slicerConfig_ = other.slicerConfig_ != null ? other.slicerConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Manifest Clone() {
      return new Manifest(this);
    }

    /// <summary>Field number for the "licenses" field.</summary>
    public const int LicensesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Uplay.Download.License> _repeated_licenses_codec
        = pb::FieldCodec.ForMessage(10, global::Uplay.Download.License.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.License> licenses_ = new pbc::RepeatedField<global::Uplay.Download.License>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.License> Licenses {
      get { return licenses_; }
    }

    /// <summary>Field number for the "installRuns" field.</summary>
    public const int InstallRunsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Uplay.Download.InstallRun> _repeated_installRuns_codec
        = pb::FieldCodec.ForMessage(18, global::Uplay.Download.InstallRun.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.InstallRun> installRuns_ = new pbc::RepeatedField<global::Uplay.Download.InstallRun>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.InstallRun> InstallRuns {
      get { return installRuns_; }
    }

    /// <summary>Field number for the "installRegistry" field.</summary>
    public const int InstallRegistryFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Uplay.Download.InstallRegistry> _repeated_installRegistry_codec
        = pb::FieldCodec.ForMessage(42, global::Uplay.Download.InstallRegistry.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.InstallRegistry> installRegistry_ = new pbc::RepeatedField<global::Uplay.Download.InstallRegistry>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.InstallRegistry> InstallRegistry {
      get { return installRegistry_; }
    }

    /// <summary>Field number for the "uninstallRuns" field.</summary>
    public const int UninstallRunsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.Download.UninstallRun> _repeated_uninstallRuns_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.Download.UninstallRun.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.UninstallRun> uninstallRuns_ = new pbc::RepeatedField<global::Uplay.Download.UninstallRun>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.UninstallRun> UninstallRuns {
      get { return uninstallRuns_; }
    }

    /// <summary>Field number for the "uninstallRegistry" field.</summary>
    public const int UninstallRegistryFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Uplay.Download.UninstallRegistry> _repeated_uninstallRegistry_codec
        = pb::FieldCodec.ForMessage(50, global::Uplay.Download.UninstallRegistry.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.UninstallRegistry> uninstallRegistry_ = new pbc::RepeatedField<global::Uplay.Download.UninstallRegistry>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.UninstallRegistry> UninstallRegistry {
      get { return uninstallRegistry_; }
    }

    /// <summary>Field number for the "chunks" field.</summary>
    public const int ChunksFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Uplay.Download.Chunk> _repeated_chunks_codec
        = pb::FieldCodec.ForMessage(34, global::Uplay.Download.Chunk.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.Chunk> chunks_ = new pbc::RepeatedField<global::Uplay.Download.Chunk>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.Chunk> Chunks {
      get { return chunks_; }
    }

    /// <summary>Field number for the "chunksVersion" field.</summary>
    public const int ChunksVersionFieldNumber = 7;
    private readonly static uint ChunksVersionDefaultValue = 0;

    private uint chunksVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ChunksVersion {
      get { if ((_hasBits0 & 1) != 0) { return chunksVersion_; } else { return ChunksVersionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        chunksVersion_ = value;
      }
    }
    /// <summary>Gets whether the "chunksVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasChunksVersion {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "chunksVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearChunksVersion() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "sliceSizeDeprecated" field.</summary>
    public const int SliceSizeDeprecatedFieldNumber = 8;
    private readonly static uint SliceSizeDeprecatedDefaultValue = 0;

    private uint sliceSizeDeprecated_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SliceSizeDeprecated {
      get { if ((_hasBits0 & 2) != 0) { return sliceSizeDeprecated_; } else { return SliceSizeDeprecatedDefaultValue; } }
      set {
        _hasBits0 |= 2;
        sliceSizeDeprecated_ = value;
      }
    }
    /// <summary>Gets whether the "sliceSizeDeprecated" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSliceSizeDeprecated {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "sliceSizeDeprecated" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSliceSizeDeprecated() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "installGameExplorer" field.</summary>
    public const int InstallGameExplorerFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Uplay.Download.InstallGameExplorer> _repeated_installGameExplorer_codec
        = pb::FieldCodec.ForMessage(74, global::Uplay.Download.InstallGameExplorer.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.InstallGameExplorer> installGameExplorer_ = new pbc::RepeatedField<global::Uplay.Download.InstallGameExplorer>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.InstallGameExplorer> InstallGameExplorer {
      get { return installGameExplorer_; }
    }

    /// <summary>Field number for the "installFirewallRules" field.</summary>
    public const int InstallFirewallRulesFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Uplay.Download.InstallFirewallRule> _repeated_installFirewallRules_codec
        = pb::FieldCodec.ForMessage(82, global::Uplay.Download.InstallFirewallRule.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.InstallFirewallRule> installFirewallRules_ = new pbc::RepeatedField<global::Uplay.Download.InstallFirewallRule>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.InstallFirewallRule> InstallFirewallRules {
      get { return installFirewallRules_; }
    }

    /// <summary>Field number for the "installCompatibility" field.</summary>
    public const int InstallCompatibilityFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Uplay.Download.InstallCompatibility> _repeated_installCompatibility_codec
        = pb::FieldCodec.ForMessage(90, global::Uplay.Download.InstallCompatibility.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.InstallCompatibility> installCompatibility_ = new pbc::RepeatedField<global::Uplay.Download.InstallCompatibility>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.InstallCompatibility> InstallCompatibility {
      get { return installCompatibility_; }
    }

    /// <summary>Field number for the "legacyInstaller" field.</summary>
    public const int LegacyInstallerFieldNumber = 12;
    private readonly static string LegacyInstallerDefaultValue = "";

    private string legacyInstaller_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LegacyInstaller {
      get { return legacyInstaller_ ?? LegacyInstallerDefaultValue; }
      set {
        legacyInstaller_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "legacyInstaller" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLegacyInstaller {
      get { return legacyInstaller_ != null; }
    }
    /// <summary>Clears the value of the "legacyInstaller" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLegacyInstaller() {
      legacyInstaller_ = null;
    }

    /// <summary>Field number for the "deprecatedLanguages" field.</summary>
    public const int DeprecatedLanguagesFieldNumber = 13;
    private static readonly pb::FieldCodec<string> _repeated_deprecatedLanguages_codec
        = pb::FieldCodec.ForString(106);
    private readonly pbc::RepeatedField<string> deprecatedLanguages_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> DeprecatedLanguages {
      get { return deprecatedLanguages_; }
    }

    /// <summary>Field number for the "isEncryptedDeprecated" field.</summary>
    public const int IsEncryptedDeprecatedFieldNumber = 14;
    private readonly static bool IsEncryptedDeprecatedDefaultValue = false;

    private bool isEncryptedDeprecated_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsEncryptedDeprecated {
      get { if ((_hasBits0 & 4) != 0) { return isEncryptedDeprecated_; } else { return IsEncryptedDeprecatedDefaultValue; } }
      set {
        _hasBits0 |= 4;
        isEncryptedDeprecated_ = value;
      }
    }
    /// <summary>Gets whether the "isEncryptedDeprecated" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsEncryptedDeprecated {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "isEncryptedDeprecated" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsEncryptedDeprecated() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "paddedSliceSizeDeprecated" field.</summary>
    public const int PaddedSliceSizeDeprecatedFieldNumber = 15;
    private readonly static uint PaddedSliceSizeDeprecatedDefaultValue = 0;

    private uint paddedSliceSizeDeprecated_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint PaddedSliceSizeDeprecated {
      get { if ((_hasBits0 & 8) != 0) { return paddedSliceSizeDeprecated_; } else { return PaddedSliceSizeDeprecatedDefaultValue; } }
      set {
        _hasBits0 |= 8;
        paddedSliceSizeDeprecated_ = value;
      }
    }
    /// <summary>Gets whether the "paddedSliceSizeDeprecated" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPaddedSliceSizeDeprecated {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "paddedSliceSizeDeprecated" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPaddedSliceSizeDeprecated() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "patchRequired" field.</summary>
    public const int PatchRequiredFieldNumber = 16;
    private readonly static bool PatchRequiredDefaultValue = false;

    private bool patchRequired_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PatchRequired {
      get { if ((_hasBits0 & 16) != 0) { return patchRequired_; } else { return PatchRequiredDefaultValue; } }
      set {
        _hasBits0 |= 16;
        patchRequired_ = value;
      }
    }
    /// <summary>Gets whether the "patchRequired" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPatchRequired {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "patchRequired" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPatchRequired() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "isCompressed" field.</summary>
    public const int IsCompressedFieldNumber = 17;
    private readonly static bool IsCompressedDefaultValue = false;

    private bool isCompressed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsCompressed {
      get { if ((_hasBits0 & 32) != 0) { return isCompressed_; } else { return IsCompressedDefaultValue; } }
      set {
        _hasBits0 |= 32;
        isCompressed_ = value;
      }
    }
    /// <summary>Gets whether the "isCompressed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsCompressed {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "isCompressed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsCompressed() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "readmeFiles" field.</summary>
    public const int ReadmeFilesFieldNumber = 18;
    private global::Uplay.Download.TextFileList readmeFiles_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.TextFileList ReadmeFiles {
      get { return readmeFiles_; }
      set {
        readmeFiles_ = value;
      }
    }

    /// <summary>Field number for the "manualFiles" field.</summary>
    public const int ManualFilesFieldNumber = 19;
    private global::Uplay.Download.TextFileList manualFiles_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.TextFileList ManualFiles {
      get { return manualFiles_; }
      set {
        manualFiles_ = value;
      }
    }

    /// <summary>Field number for the "gameVersion" field.</summary>
    public const int GameVersionFieldNumber = 20;
    private readonly static string GameVersionDefaultValue = "";

    private string gameVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string GameVersion {
      get { return gameVersion_ ?? GameVersionDefaultValue; }
      set {
        gameVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gameVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGameVersion {
      get { return gameVersion_ != null; }
    }
    /// <summary>Clears the value of the "gameVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGameVersion() {
      gameVersion_ = null;
    }

    /// <summary>Field number for the "compressionMethod" field.</summary>
    public const int CompressionMethodFieldNumber = 21;
    private readonly static global::Uplay.Download.CompressionMethod CompressionMethodDefaultValue = global::Uplay.Download.CompressionMethod.Deflate;

    private global::Uplay.Download.CompressionMethod compressionMethod_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.CompressionMethod CompressionMethod {
      get { if ((_hasBits0 & 64) != 0) { return compressionMethod_; } else { return CompressionMethodDefaultValue; } }
      set {
        _hasBits0 |= 64;
        compressionMethod_ = value;
      }
    }
    /// <summary>Gets whether the "compressionMethod" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCompressionMethod {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "compressionMethod" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCompressionMethod() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 22;
    private readonly static uint VersionDefaultValue = 0;

    private uint version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Version {
      get { if ((_hasBits0 & 128) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 128;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "languages" field.</summary>
    public const int LanguagesFieldNumber = 23;
    private static readonly pb::FieldCodec<global::Uplay.Download.Language> _repeated_languages_codec
        = pb::FieldCodec.ForMessage(186, global::Uplay.Download.Language.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.Language> languages_ = new pbc::RepeatedField<global::Uplay.Download.Language>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.Language> Languages {
      get { return languages_; }
    }

    /// <summary>Field number for the "slicerConfig" field.</summary>
    public const int SlicerConfigFieldNumber = 24;
    private global::Uplay.Download.SlicerConfig slicerConfig_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.Download.SlicerConfig SlicerConfig {
      get { return slicerConfig_; }
      set {
        slicerConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Manifest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Manifest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!licenses_.Equals(other.licenses_)) return false;
      if(!installRuns_.Equals(other.installRuns_)) return false;
      if(!installRegistry_.Equals(other.installRegistry_)) return false;
      if(!uninstallRuns_.Equals(other.uninstallRuns_)) return false;
      if(!uninstallRegistry_.Equals(other.uninstallRegistry_)) return false;
      if(!chunks_.Equals(other.chunks_)) return false;
      if (ChunksVersion != other.ChunksVersion) return false;
      if (SliceSizeDeprecated != other.SliceSizeDeprecated) return false;
      if(!installGameExplorer_.Equals(other.installGameExplorer_)) return false;
      if(!installFirewallRules_.Equals(other.installFirewallRules_)) return false;
      if(!installCompatibility_.Equals(other.installCompatibility_)) return false;
      if (LegacyInstaller != other.LegacyInstaller) return false;
      if(!deprecatedLanguages_.Equals(other.deprecatedLanguages_)) return false;
      if (IsEncryptedDeprecated != other.IsEncryptedDeprecated) return false;
      if (PaddedSliceSizeDeprecated != other.PaddedSliceSizeDeprecated) return false;
      if (PatchRequired != other.PatchRequired) return false;
      if (IsCompressed != other.IsCompressed) return false;
      if (!object.Equals(ReadmeFiles, other.ReadmeFiles)) return false;
      if (!object.Equals(ManualFiles, other.ManualFiles)) return false;
      if (GameVersion != other.GameVersion) return false;
      if (CompressionMethod != other.CompressionMethod) return false;
      if (Version != other.Version) return false;
      if(!languages_.Equals(other.languages_)) return false;
      if (!object.Equals(SlicerConfig, other.SlicerConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= licenses_.GetHashCode();
      hash ^= installRuns_.GetHashCode();
      hash ^= installRegistry_.GetHashCode();
      hash ^= uninstallRuns_.GetHashCode();
      hash ^= uninstallRegistry_.GetHashCode();
      hash ^= chunks_.GetHashCode();
      if (HasChunksVersion) hash ^= ChunksVersion.GetHashCode();
      if (HasSliceSizeDeprecated) hash ^= SliceSizeDeprecated.GetHashCode();
      hash ^= installGameExplorer_.GetHashCode();
      hash ^= installFirewallRules_.GetHashCode();
      hash ^= installCompatibility_.GetHashCode();
      if (HasLegacyInstaller) hash ^= LegacyInstaller.GetHashCode();
      hash ^= deprecatedLanguages_.GetHashCode();
      if (HasIsEncryptedDeprecated) hash ^= IsEncryptedDeprecated.GetHashCode();
      if (HasPaddedSliceSizeDeprecated) hash ^= PaddedSliceSizeDeprecated.GetHashCode();
      if (HasPatchRequired) hash ^= PatchRequired.GetHashCode();
      if (HasIsCompressed) hash ^= IsCompressed.GetHashCode();
      if (readmeFiles_ != null) hash ^= ReadmeFiles.GetHashCode();
      if (manualFiles_ != null) hash ^= ManualFiles.GetHashCode();
      if (HasGameVersion) hash ^= GameVersion.GetHashCode();
      if (HasCompressionMethod) hash ^= CompressionMethod.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      hash ^= languages_.GetHashCode();
      if (slicerConfig_ != null) hash ^= SlicerConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      licenses_.WriteTo(output, _repeated_licenses_codec);
      installRuns_.WriteTo(output, _repeated_installRuns_codec);
      uninstallRuns_.WriteTo(output, _repeated_uninstallRuns_codec);
      chunks_.WriteTo(output, _repeated_chunks_codec);
      installRegistry_.WriteTo(output, _repeated_installRegistry_codec);
      uninstallRegistry_.WriteTo(output, _repeated_uninstallRegistry_codec);
      if (HasChunksVersion) {
        output.WriteRawTag(56);
        output.WriteUInt32(ChunksVersion);
      }
      if (HasSliceSizeDeprecated) {
        output.WriteRawTag(64);
        output.WriteUInt32(SliceSizeDeprecated);
      }
      installGameExplorer_.WriteTo(output, _repeated_installGameExplorer_codec);
      installFirewallRules_.WriteTo(output, _repeated_installFirewallRules_codec);
      installCompatibility_.WriteTo(output, _repeated_installCompatibility_codec);
      if (HasLegacyInstaller) {
        output.WriteRawTag(98);
        output.WriteString(LegacyInstaller);
      }
      deprecatedLanguages_.WriteTo(output, _repeated_deprecatedLanguages_codec);
      if (HasIsEncryptedDeprecated) {
        output.WriteRawTag(112);
        output.WriteBool(IsEncryptedDeprecated);
      }
      if (HasPaddedSliceSizeDeprecated) {
        output.WriteRawTag(120);
        output.WriteUInt32(PaddedSliceSizeDeprecated);
      }
      if (HasPatchRequired) {
        output.WriteRawTag(128, 1);
        output.WriteBool(PatchRequired);
      }
      if (HasIsCompressed) {
        output.WriteRawTag(136, 1);
        output.WriteBool(IsCompressed);
      }
      if (readmeFiles_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(ReadmeFiles);
      }
      if (manualFiles_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ManualFiles);
      }
      if (HasGameVersion) {
        output.WriteRawTag(162, 1);
        output.WriteString(GameVersion);
      }
      if (HasCompressionMethod) {
        output.WriteRawTag(168, 1);
        output.WriteEnum((int) CompressionMethod);
      }
      if (HasVersion) {
        output.WriteRawTag(176, 1);
        output.WriteUInt32(Version);
      }
      languages_.WriteTo(output, _repeated_languages_codec);
      if (slicerConfig_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(SlicerConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      licenses_.WriteTo(ref output, _repeated_licenses_codec);
      installRuns_.WriteTo(ref output, _repeated_installRuns_codec);
      uninstallRuns_.WriteTo(ref output, _repeated_uninstallRuns_codec);
      chunks_.WriteTo(ref output, _repeated_chunks_codec);
      installRegistry_.WriteTo(ref output, _repeated_installRegistry_codec);
      uninstallRegistry_.WriteTo(ref output, _repeated_uninstallRegistry_codec);
      if (HasChunksVersion) {
        output.WriteRawTag(56);
        output.WriteUInt32(ChunksVersion);
      }
      if (HasSliceSizeDeprecated) {
        output.WriteRawTag(64);
        output.WriteUInt32(SliceSizeDeprecated);
      }
      installGameExplorer_.WriteTo(ref output, _repeated_installGameExplorer_codec);
      installFirewallRules_.WriteTo(ref output, _repeated_installFirewallRules_codec);
      installCompatibility_.WriteTo(ref output, _repeated_installCompatibility_codec);
      if (HasLegacyInstaller) {
        output.WriteRawTag(98);
        output.WriteString(LegacyInstaller);
      }
      deprecatedLanguages_.WriteTo(ref output, _repeated_deprecatedLanguages_codec);
      if (HasIsEncryptedDeprecated) {
        output.WriteRawTag(112);
        output.WriteBool(IsEncryptedDeprecated);
      }
      if (HasPaddedSliceSizeDeprecated) {
        output.WriteRawTag(120);
        output.WriteUInt32(PaddedSliceSizeDeprecated);
      }
      if (HasPatchRequired) {
        output.WriteRawTag(128, 1);
        output.WriteBool(PatchRequired);
      }
      if (HasIsCompressed) {
        output.WriteRawTag(136, 1);
        output.WriteBool(IsCompressed);
      }
      if (readmeFiles_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(ReadmeFiles);
      }
      if (manualFiles_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ManualFiles);
      }
      if (HasGameVersion) {
        output.WriteRawTag(162, 1);
        output.WriteString(GameVersion);
      }
      if (HasCompressionMethod) {
        output.WriteRawTag(168, 1);
        output.WriteEnum((int) CompressionMethod);
      }
      if (HasVersion) {
        output.WriteRawTag(176, 1);
        output.WriteUInt32(Version);
      }
      languages_.WriteTo(ref output, _repeated_languages_codec);
      if (slicerConfig_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(SlicerConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += licenses_.CalculateSize(_repeated_licenses_codec);
      size += installRuns_.CalculateSize(_repeated_installRuns_codec);
      size += installRegistry_.CalculateSize(_repeated_installRegistry_codec);
      size += uninstallRuns_.CalculateSize(_repeated_uninstallRuns_codec);
      size += uninstallRegistry_.CalculateSize(_repeated_uninstallRegistry_codec);
      size += chunks_.CalculateSize(_repeated_chunks_codec);
      if (HasChunksVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ChunksVersion);
      }
      if (HasSliceSizeDeprecated) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SliceSizeDeprecated);
      }
      size += installGameExplorer_.CalculateSize(_repeated_installGameExplorer_codec);
      size += installFirewallRules_.CalculateSize(_repeated_installFirewallRules_codec);
      size += installCompatibility_.CalculateSize(_repeated_installCompatibility_codec);
      if (HasLegacyInstaller) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LegacyInstaller);
      }
      size += deprecatedLanguages_.CalculateSize(_repeated_deprecatedLanguages_codec);
      if (HasIsEncryptedDeprecated) {
        size += 1 + 1;
      }
      if (HasPaddedSliceSizeDeprecated) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PaddedSliceSizeDeprecated);
      }
      if (HasPatchRequired) {
        size += 2 + 1;
      }
      if (HasIsCompressed) {
        size += 2 + 1;
      }
      if (readmeFiles_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ReadmeFiles);
      }
      if (manualFiles_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ManualFiles);
      }
      if (HasGameVersion) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(GameVersion);
      }
      if (HasCompressionMethod) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) CompressionMethod);
      }
      if (HasVersion) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(Version);
      }
      size += languages_.CalculateSize(_repeated_languages_codec);
      if (slicerConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SlicerConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Manifest other) {
      if (other == null) {
        return;
      }
      licenses_.Add(other.licenses_);
      installRuns_.Add(other.installRuns_);
      installRegistry_.Add(other.installRegistry_);
      uninstallRuns_.Add(other.uninstallRuns_);
      uninstallRegistry_.Add(other.uninstallRegistry_);
      chunks_.Add(other.chunks_);
      if (other.HasChunksVersion) {
        ChunksVersion = other.ChunksVersion;
      }
      if (other.HasSliceSizeDeprecated) {
        SliceSizeDeprecated = other.SliceSizeDeprecated;
      }
      installGameExplorer_.Add(other.installGameExplorer_);
      installFirewallRules_.Add(other.installFirewallRules_);
      installCompatibility_.Add(other.installCompatibility_);
      if (other.HasLegacyInstaller) {
        LegacyInstaller = other.LegacyInstaller;
      }
      deprecatedLanguages_.Add(other.deprecatedLanguages_);
      if (other.HasIsEncryptedDeprecated) {
        IsEncryptedDeprecated = other.IsEncryptedDeprecated;
      }
      if (other.HasPaddedSliceSizeDeprecated) {
        PaddedSliceSizeDeprecated = other.PaddedSliceSizeDeprecated;
      }
      if (other.HasPatchRequired) {
        PatchRequired = other.PatchRequired;
      }
      if (other.HasIsCompressed) {
        IsCompressed = other.IsCompressed;
      }
      if (other.readmeFiles_ != null) {
        if (readmeFiles_ == null) {
          ReadmeFiles = new global::Uplay.Download.TextFileList();
        }
        ReadmeFiles.MergeFrom(other.ReadmeFiles);
      }
      if (other.manualFiles_ != null) {
        if (manualFiles_ == null) {
          ManualFiles = new global::Uplay.Download.TextFileList();
        }
        ManualFiles.MergeFrom(other.ManualFiles);
      }
      if (other.HasGameVersion) {
        GameVersion = other.GameVersion;
      }
      if (other.HasCompressionMethod) {
        CompressionMethod = other.CompressionMethod;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      languages_.Add(other.languages_);
      if (other.slicerConfig_ != null) {
        if (slicerConfig_ == null) {
          SlicerConfig = new global::Uplay.Download.SlicerConfig();
        }
        SlicerConfig.MergeFrom(other.SlicerConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            licenses_.AddEntriesFrom(input, _repeated_licenses_codec);
            break;
          }
          case 18: {
            installRuns_.AddEntriesFrom(input, _repeated_installRuns_codec);
            break;
          }
          case 26: {
            uninstallRuns_.AddEntriesFrom(input, _repeated_uninstallRuns_codec);
            break;
          }
          case 34: {
            chunks_.AddEntriesFrom(input, _repeated_chunks_codec);
            break;
          }
          case 42: {
            installRegistry_.AddEntriesFrom(input, _repeated_installRegistry_codec);
            break;
          }
          case 50: {
            uninstallRegistry_.AddEntriesFrom(input, _repeated_uninstallRegistry_codec);
            break;
          }
          case 56: {
            ChunksVersion = input.ReadUInt32();
            break;
          }
          case 64: {
            SliceSizeDeprecated = input.ReadUInt32();
            break;
          }
          case 74: {
            installGameExplorer_.AddEntriesFrom(input, _repeated_installGameExplorer_codec);
            break;
          }
          case 82: {
            installFirewallRules_.AddEntriesFrom(input, _repeated_installFirewallRules_codec);
            break;
          }
          case 90: {
            installCompatibility_.AddEntriesFrom(input, _repeated_installCompatibility_codec);
            break;
          }
          case 98: {
            LegacyInstaller = input.ReadString();
            break;
          }
          case 106: {
            deprecatedLanguages_.AddEntriesFrom(input, _repeated_deprecatedLanguages_codec);
            break;
          }
          case 112: {
            IsEncryptedDeprecated = input.ReadBool();
            break;
          }
          case 120: {
            PaddedSliceSizeDeprecated = input.ReadUInt32();
            break;
          }
          case 128: {
            PatchRequired = input.ReadBool();
            break;
          }
          case 136: {
            IsCompressed = input.ReadBool();
            break;
          }
          case 146: {
            if (readmeFiles_ == null) {
              ReadmeFiles = new global::Uplay.Download.TextFileList();
            }
            input.ReadMessage(ReadmeFiles);
            break;
          }
          case 154: {
            if (manualFiles_ == null) {
              ManualFiles = new global::Uplay.Download.TextFileList();
            }
            input.ReadMessage(ManualFiles);
            break;
          }
          case 162: {
            GameVersion = input.ReadString();
            break;
          }
          case 168: {
            CompressionMethod = (global::Uplay.Download.CompressionMethod) input.ReadEnum();
            break;
          }
          case 176: {
            Version = input.ReadUInt32();
            break;
          }
          case 186: {
            languages_.AddEntriesFrom(input, _repeated_languages_codec);
            break;
          }
          case 194: {
            if (slicerConfig_ == null) {
              SlicerConfig = new global::Uplay.Download.SlicerConfig();
            }
            input.ReadMessage(SlicerConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            licenses_.AddEntriesFrom(ref input, _repeated_licenses_codec);
            break;
          }
          case 18: {
            installRuns_.AddEntriesFrom(ref input, _repeated_installRuns_codec);
            break;
          }
          case 26: {
            uninstallRuns_.AddEntriesFrom(ref input, _repeated_uninstallRuns_codec);
            break;
          }
          case 34: {
            chunks_.AddEntriesFrom(ref input, _repeated_chunks_codec);
            break;
          }
          case 42: {
            installRegistry_.AddEntriesFrom(ref input, _repeated_installRegistry_codec);
            break;
          }
          case 50: {
            uninstallRegistry_.AddEntriesFrom(ref input, _repeated_uninstallRegistry_codec);
            break;
          }
          case 56: {
            ChunksVersion = input.ReadUInt32();
            break;
          }
          case 64: {
            SliceSizeDeprecated = input.ReadUInt32();
            break;
          }
          case 74: {
            installGameExplorer_.AddEntriesFrom(ref input, _repeated_installGameExplorer_codec);
            break;
          }
          case 82: {
            installFirewallRules_.AddEntriesFrom(ref input, _repeated_installFirewallRules_codec);
            break;
          }
          case 90: {
            installCompatibility_.AddEntriesFrom(ref input, _repeated_installCompatibility_codec);
            break;
          }
          case 98: {
            LegacyInstaller = input.ReadString();
            break;
          }
          case 106: {
            deprecatedLanguages_.AddEntriesFrom(ref input, _repeated_deprecatedLanguages_codec);
            break;
          }
          case 112: {
            IsEncryptedDeprecated = input.ReadBool();
            break;
          }
          case 120: {
            PaddedSliceSizeDeprecated = input.ReadUInt32();
            break;
          }
          case 128: {
            PatchRequired = input.ReadBool();
            break;
          }
          case 136: {
            IsCompressed = input.ReadBool();
            break;
          }
          case 146: {
            if (readmeFiles_ == null) {
              ReadmeFiles = new global::Uplay.Download.TextFileList();
            }
            input.ReadMessage(ReadmeFiles);
            break;
          }
          case 154: {
            if (manualFiles_ == null) {
              ManualFiles = new global::Uplay.Download.TextFileList();
            }
            input.ReadMessage(ManualFiles);
            break;
          }
          case 162: {
            GameVersion = input.ReadString();
            break;
          }
          case 168: {
            CompressionMethod = (global::Uplay.Download.CompressionMethod) input.ReadEnum();
            break;
          }
          case 176: {
            Version = input.ReadUInt32();
            break;
          }
          case 186: {
            languages_.AddEntriesFrom(ref input, _repeated_languages_codec);
            break;
          }
          case 194: {
            if (slicerConfig_ == null) {
              SlicerConfig = new global::Uplay.Download.SlicerConfig();
            }
            input.ReadMessage(SlicerConfig);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ManifestLicenses : pb::IMessage<ManifestLicenses>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ManifestLicenses> _parser = new pb::MessageParser<ManifestLicenses>(() => new ManifestLicenses());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ManifestLicenses> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ManifestLicenses() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ManifestLicenses(ManifestLicenses other) : this() {
      licenses_ = other.licenses_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ManifestLicenses Clone() {
      return new ManifestLicenses(this);
    }

    /// <summary>Field number for the "licenses" field.</summary>
    public const int LicensesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Uplay.Download.License> _repeated_licenses_codec
        = pb::FieldCodec.ForMessage(10, global::Uplay.Download.License.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.License> licenses_ = new pbc::RepeatedField<global::Uplay.Download.License>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.License> Licenses {
      get { return licenses_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ManifestLicenses);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ManifestLicenses other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!licenses_.Equals(other.licenses_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= licenses_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      licenses_.WriteTo(output, _repeated_licenses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      licenses_.WriteTo(ref output, _repeated_licenses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += licenses_.CalculateSize(_repeated_licenses_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ManifestLicenses other) {
      if (other == null) {
        return;
      }
      licenses_.Add(other.licenses_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            licenses_.AddEntriesFrom(input, _repeated_licenses_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            licenses_.AddEntriesFrom(ref input, _repeated_licenses_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ManifestMetaData : pb::IMessage<ManifestMetaData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ManifestMetaData> _parser = new pb::MessageParser<ManifestMetaData>(() => new ManifestMetaData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ManifestMetaData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.Download.DownloadReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ManifestMetaData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ManifestMetaData(ManifestMetaData other) : this() {
      _hasBits0 = other._hasBits0;
      licenses_ = other.licenses_.Clone();
      bytesOnDisk_ = other.bytesOnDisk_;
      bytesToDownload_ = other.bytesToDownload_;
      deprecatedLanguages_ = other.deprecatedLanguages_.Clone();
      chunksVersion_ = other.chunksVersion_;
      uplayIds_ = other.uplayIds_.Clone();
      chunks_ = other.chunks_.Clone();
      paddedBytesOnDisk_ = other.paddedBytesOnDisk_;
      languages_ = other.languages_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ManifestMetaData Clone() {
      return new ManifestMetaData(this);
    }

    /// <summary>Field number for the "licenses" field.</summary>
    public const int LicensesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Uplay.Download.License> _repeated_licenses_codec
        = pb::FieldCodec.ForMessage(10, global::Uplay.Download.License.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.License> licenses_ = new pbc::RepeatedField<global::Uplay.Download.License>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.License> Licenses {
      get { return licenses_; }
    }

    /// <summary>Field number for the "bytesOnDisk" field.</summary>
    public const int BytesOnDiskFieldNumber = 2;
    private readonly static ulong BytesOnDiskDefaultValue = 0UL;

    private ulong bytesOnDisk_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong BytesOnDisk {
      get { if ((_hasBits0 & 1) != 0) { return bytesOnDisk_; } else { return BytesOnDiskDefaultValue; } }
      set {
        _hasBits0 |= 1;
        bytesOnDisk_ = value;
      }
    }
    /// <summary>Gets whether the "bytesOnDisk" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBytesOnDisk {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "bytesOnDisk" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBytesOnDisk() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "bytesToDownload" field.</summary>
    public const int BytesToDownloadFieldNumber = 3;
    private readonly static ulong BytesToDownloadDefaultValue = 0UL;

    private ulong bytesToDownload_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong BytesToDownload {
      get { if ((_hasBits0 & 2) != 0) { return bytesToDownload_; } else { return BytesToDownloadDefaultValue; } }
      set {
        _hasBits0 |= 2;
        bytesToDownload_ = value;
      }
    }
    /// <summary>Gets whether the "bytesToDownload" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBytesToDownload {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "bytesToDownload" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBytesToDownload() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "deprecatedLanguages" field.</summary>
    public const int DeprecatedLanguagesFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_deprecatedLanguages_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> deprecatedLanguages_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> DeprecatedLanguages {
      get { return deprecatedLanguages_; }
    }

    /// <summary>Field number for the "chunksVersion" field.</summary>
    public const int ChunksVersionFieldNumber = 6;
    private readonly static uint ChunksVersionDefaultValue = 0;

    private uint chunksVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ChunksVersion {
      get { if ((_hasBits0 & 4) != 0) { return chunksVersion_; } else { return ChunksVersionDefaultValue; } }
      set {
        _hasBits0 |= 4;
        chunksVersion_ = value;
      }
    }
    /// <summary>Gets whether the "chunksVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasChunksVersion {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "chunksVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearChunksVersion() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "uplayIds" field.</summary>
    public const int UplayIdsFieldNumber = 7;
    private static readonly pb::FieldCodec<uint> _repeated_uplayIds_codec
        = pb::FieldCodec.ForUInt32(56);
    private readonly pbc::RepeatedField<uint> uplayIds_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> UplayIds {
      get { return uplayIds_; }
    }

    /// <summary>Field number for the "chunks" field.</summary>
    public const int ChunksFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Uplay.Download.MetaDataChunk> _repeated_chunks_codec
        = pb::FieldCodec.ForMessage(66, global::Uplay.Download.MetaDataChunk.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.MetaDataChunk> chunks_ = new pbc::RepeatedField<global::Uplay.Download.MetaDataChunk>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.MetaDataChunk> Chunks {
      get { return chunks_; }
    }

    /// <summary>Field number for the "paddedBytesOnDisk" field.</summary>
    public const int PaddedBytesOnDiskFieldNumber = 9;
    private readonly static ulong PaddedBytesOnDiskDefaultValue = 0UL;

    private ulong paddedBytesOnDisk_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong PaddedBytesOnDisk {
      get { if ((_hasBits0 & 8) != 0) { return paddedBytesOnDisk_; } else { return PaddedBytesOnDiskDefaultValue; } }
      set {
        _hasBits0 |= 8;
        paddedBytesOnDisk_ = value;
      }
    }
    /// <summary>Gets whether the "paddedBytesOnDisk" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPaddedBytesOnDisk {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "paddedBytesOnDisk" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPaddedBytesOnDisk() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "languages" field.</summary>
    public const int LanguagesFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Uplay.Download.Language> _repeated_languages_codec
        = pb::FieldCodec.ForMessage(82, global::Uplay.Download.Language.Parser);
    private readonly pbc::RepeatedField<global::Uplay.Download.Language> languages_ = new pbc::RepeatedField<global::Uplay.Download.Language>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.Download.Language> Languages {
      get { return languages_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ManifestMetaData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ManifestMetaData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!licenses_.Equals(other.licenses_)) return false;
      if (BytesOnDisk != other.BytesOnDisk) return false;
      if (BytesToDownload != other.BytesToDownload) return false;
      if(!deprecatedLanguages_.Equals(other.deprecatedLanguages_)) return false;
      if (ChunksVersion != other.ChunksVersion) return false;
      if(!uplayIds_.Equals(other.uplayIds_)) return false;
      if(!chunks_.Equals(other.chunks_)) return false;
      if (PaddedBytesOnDisk != other.PaddedBytesOnDisk) return false;
      if(!languages_.Equals(other.languages_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= licenses_.GetHashCode();
      if (HasBytesOnDisk) hash ^= BytesOnDisk.GetHashCode();
      if (HasBytesToDownload) hash ^= BytesToDownload.GetHashCode();
      hash ^= deprecatedLanguages_.GetHashCode();
      if (HasChunksVersion) hash ^= ChunksVersion.GetHashCode();
      hash ^= uplayIds_.GetHashCode();
      hash ^= chunks_.GetHashCode();
      if (HasPaddedBytesOnDisk) hash ^= PaddedBytesOnDisk.GetHashCode();
      hash ^= languages_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      licenses_.WriteTo(output, _repeated_licenses_codec);
      if (HasBytesOnDisk) {
        output.WriteRawTag(16);
        output.WriteUInt64(BytesOnDisk);
      }
      if (HasBytesToDownload) {
        output.WriteRawTag(24);
        output.WriteUInt64(BytesToDownload);
      }
      deprecatedLanguages_.WriteTo(output, _repeated_deprecatedLanguages_codec);
      if (HasChunksVersion) {
        output.WriteRawTag(48);
        output.WriteUInt32(ChunksVersion);
      }
      uplayIds_.WriteTo(output, _repeated_uplayIds_codec);
      chunks_.WriteTo(output, _repeated_chunks_codec);
      if (HasPaddedBytesOnDisk) {
        output.WriteRawTag(72);
        output.WriteUInt64(PaddedBytesOnDisk);
      }
      languages_.WriteTo(output, _repeated_languages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      licenses_.WriteTo(ref output, _repeated_licenses_codec);
      if (HasBytesOnDisk) {
        output.WriteRawTag(16);
        output.WriteUInt64(BytesOnDisk);
      }
      if (HasBytesToDownload) {
        output.WriteRawTag(24);
        output.WriteUInt64(BytesToDownload);
      }
      deprecatedLanguages_.WriteTo(ref output, _repeated_deprecatedLanguages_codec);
      if (HasChunksVersion) {
        output.WriteRawTag(48);
        output.WriteUInt32(ChunksVersion);
      }
      uplayIds_.WriteTo(ref output, _repeated_uplayIds_codec);
      chunks_.WriteTo(ref output, _repeated_chunks_codec);
      if (HasPaddedBytesOnDisk) {
        output.WriteRawTag(72);
        output.WriteUInt64(PaddedBytesOnDisk);
      }
      languages_.WriteTo(ref output, _repeated_languages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += licenses_.CalculateSize(_repeated_licenses_codec);
      if (HasBytesOnDisk) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(BytesOnDisk);
      }
      if (HasBytesToDownload) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(BytesToDownload);
      }
      size += deprecatedLanguages_.CalculateSize(_repeated_deprecatedLanguages_codec);
      if (HasChunksVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ChunksVersion);
      }
      size += uplayIds_.CalculateSize(_repeated_uplayIds_codec);
      size += chunks_.CalculateSize(_repeated_chunks_codec);
      if (HasPaddedBytesOnDisk) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(PaddedBytesOnDisk);
      }
      size += languages_.CalculateSize(_repeated_languages_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ManifestMetaData other) {
      if (other == null) {
        return;
      }
      licenses_.Add(other.licenses_);
      if (other.HasBytesOnDisk) {
        BytesOnDisk = other.BytesOnDisk;
      }
      if (other.HasBytesToDownload) {
        BytesToDownload = other.BytesToDownload;
      }
      deprecatedLanguages_.Add(other.deprecatedLanguages_);
      if (other.HasChunksVersion) {
        ChunksVersion = other.ChunksVersion;
      }
      uplayIds_.Add(other.uplayIds_);
      chunks_.Add(other.chunks_);
      if (other.HasPaddedBytesOnDisk) {
        PaddedBytesOnDisk = other.PaddedBytesOnDisk;
      }
      languages_.Add(other.languages_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            licenses_.AddEntriesFrom(input, _repeated_licenses_codec);
            break;
          }
          case 16: {
            BytesOnDisk = input.ReadUInt64();
            break;
          }
          case 24: {
            BytesToDownload = input.ReadUInt64();
            break;
          }
          case 42: {
            deprecatedLanguages_.AddEntriesFrom(input, _repeated_deprecatedLanguages_codec);
            break;
          }
          case 48: {
            ChunksVersion = input.ReadUInt32();
            break;
          }
          case 58:
          case 56: {
            uplayIds_.AddEntriesFrom(input, _repeated_uplayIds_codec);
            break;
          }
          case 66: {
            chunks_.AddEntriesFrom(input, _repeated_chunks_codec);
            break;
          }
          case 72: {
            PaddedBytesOnDisk = input.ReadUInt64();
            break;
          }
          case 82: {
            languages_.AddEntriesFrom(input, _repeated_languages_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            licenses_.AddEntriesFrom(ref input, _repeated_licenses_codec);
            break;
          }
          case 16: {
            BytesOnDisk = input.ReadUInt64();
            break;
          }
          case 24: {
            BytesToDownload = input.ReadUInt64();
            break;
          }
          case 42: {
            deprecatedLanguages_.AddEntriesFrom(ref input, _repeated_deprecatedLanguages_codec);
            break;
          }
          case 48: {
            ChunksVersion = input.ReadUInt32();
            break;
          }
          case 58:
          case 56: {
            uplayIds_.AddEntriesFrom(ref input, _repeated_uplayIds_codec);
            break;
          }
          case 66: {
            chunks_.AddEntriesFrom(ref input, _repeated_chunks_codec);
            break;
          }
          case 72: {
            PaddedBytesOnDisk = input.ReadUInt64();
            break;
          }
          case 82: {
            languages_.AddEntriesFrom(ref input, _repeated_languages_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
