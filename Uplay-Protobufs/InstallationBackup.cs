// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: installation_backup.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Uplay.InstallationBackup {

  /// <summary>Holder for reflection information generated from installation_backup.proto</summary>
  public static partial class InstallationBackupReflection {

    #region Descriptor
    /// <summary>File descriptor for installation_backup.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static InstallationBackupReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiV1cGNfZHVtcF8xMC9pbnN0YWxsYXRpb25fYmFja3VwLnByb3RvEh9tZy5w",
            "cm90b2NvbC5pbnN0YWxsYXRpb25fYmFja3VwIksKDUxpY2Vuc2VMb2NhbGUS",
            "EAoIbGFuZ3VhZ2UYASACKAkSDAoEc2hhMRgCIAIoDBIMCgR0ZXh0GAMgASgJ",
            "EgwKBG5hbWUYBCABKAkirwEKB0xpY2Vuc2USEgoKaWRlbnRpZmllchgBIAIo",
            "CRIPCgd2ZXJzaW9uGAIgAigNEj8KB2xvY2FsZXMYAyADKAsyLi5tZy5wcm90",
            "b2NvbC5pbnN0YWxsYXRpb25fYmFja3VwLkxpY2Vuc2VMb2NhbGUSPgoGZm9y",
            "bWF0GAQgASgOMi4ubWcucHJvdG9jb2wuaW5zdGFsbGF0aW9uX2JhY2t1cC5M",
            "aWNlbnNlRm9ybWF0IjMKBVNsaWNlEgwKBHNoYTEYASABKAwSDAoEc2l6ZRgC",
            "IAEoDRIOCgZvZmZzZXQYAyABKAQiYQoHQXJjaGl2ZRIQCghmaWxlbmFtZRgB",
            "IAEoCRIMCgRzaXplGAIgASgEEjYKBnNsaWNlcxgDIAMoCzImLm1nLnByb3Rv",
            "Y29sLmluc3RhbGxhdGlvbl9iYWNrdXAuU2xpY2UiYQoERGlzYxIOCgZudW1i",
            "ZXIYASABKA0SDQoFbGFiZWwYAiABKAkSOgoIYXJjaGl2ZXMYAyADKAsyKC5t",
            "Zy5wcm90b2NvbC5pbnN0YWxsYXRpb25fYmFja3VwLkFyY2hpdmUiLgoIVGV4",
            "dEZpbGUSEAoIbGFuZ3VhZ2UYASACKAkSEAoIZmlsZU5hbWUYAiACKAkinAEK",
            "B0F1dG9ydW4SEQoJZ2FtZVRpdGxlGAEgASgJEj4KC3JlYWRtZUZpbGVzGAIg",
            "AygLMikubWcucHJvdG9jb2wuaW5zdGFsbGF0aW9uX2JhY2t1cC5UZXh0Rmls",
            "ZRI+CgttYW51YWxGaWxlcxgDIAMoCzIpLm1nLnByb3RvY29sLmluc3RhbGxh",
            "dGlvbl9iYWNrdXAuVGV4dEZpbGUizgIKEkluc3RhbGxhdGlvbkJhY2t1cBIP",
            "Cgd2ZXJzaW9uGAEgAigNEhEKCXByb2R1Y3RJZBgCIAEoDRI0CgVkaXNjcxgD",
            "IAMoCzIlLm1nLnByb3RvY29sLmluc3RhbGxhdGlvbl9iYWNrdXAuRGlzYxI6",
            "CghsaWNlbnNlcxgEIAMoCzIoLm1nLnByb3RvY29sLmluc3RhbGxhdGlvbl9i",
            "YWNrdXAuTGljZW5zZRIUCgxtYW5pZmVzdFNoYTEYBSABKAkSEwoLZW52aXJv",
            "bm1lbnQYBiABKAkSOQoHYXV0b3J1bhgHIAEoCzIoLm1nLnByb3RvY29sLmlu",
            "c3RhbGxhdGlvbl9iYWNrdXAuQXV0b3J1bhIRCglsYW5ndWFnZXMYCCADKAkS",
            "DAoEc2hhMRgJIAEoDBIbChNwcm9kdWN0UGFja1VwbGF5SWRzGAogAygNKj8K",
            "DUxpY2Vuc2VGb3JtYXQSFgoSTGljZW5zZUZvcm1hdF9UZXh0EAESFgoSTGlj",
            "ZW5zZUZvcm1hdF9IdG1sEAI="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Uplay.InstallationBackup.LicenseFormat), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.InstallationBackup.LicenseLocale), global::Uplay.InstallationBackup.LicenseLocale.Parser, new[]{ "Language", "Sha1", "Text", "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.InstallationBackup.License), global::Uplay.InstallationBackup.License.Parser, new[]{ "Identifier", "Version", "Locales", "Format" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.InstallationBackup.Slice), global::Uplay.InstallationBackup.Slice.Parser, new[]{ "Sha1", "Size", "Offset" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.InstallationBackup.Archive), global::Uplay.InstallationBackup.Archive.Parser, new[]{ "Filename", "Size", "Slices" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.InstallationBackup.Disc), global::Uplay.InstallationBackup.Disc.Parser, new[]{ "Number", "Label", "Archives" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.InstallationBackup.TextFile), global::Uplay.InstallationBackup.TextFile.Parser, new[]{ "Language", "FileName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.InstallationBackup.Autorun), global::Uplay.InstallationBackup.Autorun.Parser, new[]{ "GameTitle", "ReadmeFiles", "ManualFiles" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Uplay.InstallationBackup.InstallationBackup), global::Uplay.InstallationBackup.InstallationBackup.Parser, new[]{ "Version", "ProductId", "Discs", "Licenses", "ManifestSha1", "Environment", "Autorun", "Languages", "Sha1", "ProductPackUplayIds" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum LicenseFormat {
    [pbr::OriginalName("LicenseFormat_Text")] Text = 1,
    [pbr::OriginalName("LicenseFormat_Html")] Html = 2,
  }

  #endregion

  #region Messages
  public sealed partial class LicenseLocale : pb::IMessage<LicenseLocale>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LicenseLocale> _parser = new pb::MessageParser<LicenseLocale>(() => new LicenseLocale());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LicenseLocale> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.InstallationBackup.InstallationBackupReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseLocale() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseLocale(LicenseLocale other) : this() {
      language_ = other.language_;
      sha1_ = other.sha1_;
      text_ = other.text_;
      name_ = other.name_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseLocale Clone() {
      return new LicenseLocale(this);
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 1;
    private readonly static string LanguageDefaultValue = "";

    private string language_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_ ?? LanguageDefaultValue; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "language" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLanguage {
      get { return language_ != null; }
    }
    /// <summary>Clears the value of the "language" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLanguage() {
      language_ = null;
    }

    /// <summary>Field number for the "sha1" field.</summary>
    public const int Sha1FieldNumber = 2;
    private readonly static pb::ByteString Sha1DefaultValue = pb::ByteString.Empty;

    private pb::ByteString sha1_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Sha1 {
      get { return sha1_ ?? Sha1DefaultValue; }
      set {
        sha1_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sha1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSha1 {
      get { return sha1_ != null; }
    }
    /// <summary>Clears the value of the "sha1" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSha1() {
      sha1_ = null;
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 3;
    private readonly static string TextDefaultValue = "";

    private string text_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Text {
      get { return text_ ?? TextDefaultValue; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasText {
      get { return text_ != null; }
    }
    /// <summary>Clears the value of the "text" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearText() {
      text_ = null;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 4;
    private readonly static string NameDefaultValue = "";

    private string name_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LicenseLocale);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LicenseLocale other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Language != other.Language) return false;
      if (Sha1 != other.Sha1) return false;
      if (Text != other.Text) return false;
      if (Name != other.Name) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLanguage) hash ^= Language.GetHashCode();
      if (HasSha1) hash ^= Sha1.GetHashCode();
      if (HasText) hash ^= Text.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasLanguage) {
        output.WriteRawTag(10);
        output.WriteString(Language);
      }
      if (HasSha1) {
        output.WriteRawTag(18);
        output.WriteBytes(Sha1);
      }
      if (HasText) {
        output.WriteRawTag(26);
        output.WriteString(Text);
      }
      if (HasName) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasLanguage) {
        output.WriteRawTag(10);
        output.WriteString(Language);
      }
      if (HasSha1) {
        output.WriteRawTag(18);
        output.WriteBytes(Sha1);
      }
      if (HasText) {
        output.WriteRawTag(26);
        output.WriteString(Text);
      }
      if (HasName) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasLanguage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (HasSha1) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Sha1);
      }
      if (HasText) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LicenseLocale other) {
      if (other == null) {
        return;
      }
      if (other.HasLanguage) {
        Language = other.Language;
      }
      if (other.HasSha1) {
        Sha1 = other.Sha1;
      }
      if (other.HasText) {
        Text = other.Text;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Language = input.ReadString();
            break;
          }
          case 18: {
            Sha1 = input.ReadBytes();
            break;
          }
          case 26: {
            Text = input.ReadString();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Language = input.ReadString();
            break;
          }
          case 18: {
            Sha1 = input.ReadBytes();
            break;
          }
          case 26: {
            Text = input.ReadString();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class License : pb::IMessage<License>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<License> _parser = new pb::MessageParser<License>(() => new License());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<License> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.InstallationBackup.InstallationBackupReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License(License other) : this() {
      _hasBits0 = other._hasBits0;
      identifier_ = other.identifier_;
      version_ = other.version_;
      locales_ = other.locales_.Clone();
      format_ = other.format_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License Clone() {
      return new License(this);
    }

    /// <summary>Field number for the "identifier" field.</summary>
    public const int IdentifierFieldNumber = 1;
    private readonly static string IdentifierDefaultValue = "";

    private string identifier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Identifier {
      get { return identifier_ ?? IdentifierDefaultValue; }
      set {
        identifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "identifier" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIdentifier {
      get { return identifier_ != null; }
    }
    /// <summary>Clears the value of the "identifier" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIdentifier() {
      identifier_ = null;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private readonly static uint VersionDefaultValue = 0;

    private uint version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Version {
      get { if ((_hasBits0 & 1) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "locales" field.</summary>
    public const int LocalesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.InstallationBackup.LicenseLocale> _repeated_locales_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.InstallationBackup.LicenseLocale.Parser);
    private readonly pbc::RepeatedField<global::Uplay.InstallationBackup.LicenseLocale> locales_ = new pbc::RepeatedField<global::Uplay.InstallationBackup.LicenseLocale>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.InstallationBackup.LicenseLocale> Locales {
      get { return locales_; }
    }

    /// <summary>Field number for the "format" field.</summary>
    public const int FormatFieldNumber = 4;
    private readonly static global::Uplay.InstallationBackup.LicenseFormat FormatDefaultValue = global::Uplay.InstallationBackup.LicenseFormat.Text;

    private global::Uplay.InstallationBackup.LicenseFormat format_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.InstallationBackup.LicenseFormat Format {
      get { if ((_hasBits0 & 2) != 0) { return format_; } else { return FormatDefaultValue; } }
      set {
        _hasBits0 |= 2;
        format_ = value;
      }
    }
    /// <summary>Gets whether the "format" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFormat {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "format" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFormat() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as License);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(License other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Identifier != other.Identifier) return false;
      if (Version != other.Version) return false;
      if(!locales_.Equals(other.locales_)) return false;
      if (Format != other.Format) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIdentifier) hash ^= Identifier.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      hash ^= locales_.GetHashCode();
      if (HasFormat) hash ^= Format.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIdentifier) {
        output.WriteRawTag(10);
        output.WriteString(Identifier);
      }
      if (HasVersion) {
        output.WriteRawTag(16);
        output.WriteUInt32(Version);
      }
      locales_.WriteTo(output, _repeated_locales_codec);
      if (HasFormat) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Format);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIdentifier) {
        output.WriteRawTag(10);
        output.WriteString(Identifier);
      }
      if (HasVersion) {
        output.WriteRawTag(16);
        output.WriteUInt32(Version);
      }
      locales_.WriteTo(ref output, _repeated_locales_codec);
      if (HasFormat) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Format);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIdentifier) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Identifier);
      }
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
      }
      size += locales_.CalculateSize(_repeated_locales_codec);
      if (HasFormat) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Format);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(License other) {
      if (other == null) {
        return;
      }
      if (other.HasIdentifier) {
        Identifier = other.Identifier;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      locales_.Add(other.locales_);
      if (other.HasFormat) {
        Format = other.Format;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Identifier = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadUInt32();
            break;
          }
          case 26: {
            locales_.AddEntriesFrom(input, _repeated_locales_codec);
            break;
          }
          case 32: {
            Format = (global::Uplay.InstallationBackup.LicenseFormat) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Identifier = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadUInt32();
            break;
          }
          case 26: {
            locales_.AddEntriesFrom(ref input, _repeated_locales_codec);
            break;
          }
          case 32: {
            Format = (global::Uplay.InstallationBackup.LicenseFormat) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Slice : pb::IMessage<Slice>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Slice> _parser = new pb::MessageParser<Slice>(() => new Slice());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Slice> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.InstallationBackup.InstallationBackupReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Slice() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Slice(Slice other) : this() {
      _hasBits0 = other._hasBits0;
      sha1_ = other.sha1_;
      size_ = other.size_;
      offset_ = other.offset_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Slice Clone() {
      return new Slice(this);
    }

    /// <summary>Field number for the "sha1" field.</summary>
    public const int Sha1FieldNumber = 1;
    private readonly static pb::ByteString Sha1DefaultValue = pb::ByteString.Empty;

    private pb::ByteString sha1_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Sha1 {
      get { return sha1_ ?? Sha1DefaultValue; }
      set {
        sha1_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sha1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSha1 {
      get { return sha1_ != null; }
    }
    /// <summary>Clears the value of the "sha1" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSha1() {
      sha1_ = null;
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 2;
    private readonly static uint SizeDefaultValue = 0;

    private uint size_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Size {
      get { if ((_hasBits0 & 1) != 0) { return size_; } else { return SizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        size_ = value;
      }
    }
    /// <summary>Gets whether the "size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "offset" field.</summary>
    public const int OffsetFieldNumber = 3;
    private readonly static ulong OffsetDefaultValue = 0UL;

    private ulong offset_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Offset {
      get { if ((_hasBits0 & 2) != 0) { return offset_; } else { return OffsetDefaultValue; } }
      set {
        _hasBits0 |= 2;
        offset_ = value;
      }
    }
    /// <summary>Gets whether the "offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOffset {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOffset() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Slice);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Slice other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Sha1 != other.Sha1) return false;
      if (Size != other.Size) return false;
      if (Offset != other.Offset) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSha1) hash ^= Sha1.GetHashCode();
      if (HasSize) hash ^= Size.GetHashCode();
      if (HasOffset) hash ^= Offset.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSha1) {
        output.WriteRawTag(10);
        output.WriteBytes(Sha1);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt32(Size);
      }
      if (HasOffset) {
        output.WriteRawTag(24);
        output.WriteUInt64(Offset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSha1) {
        output.WriteRawTag(10);
        output.WriteBytes(Sha1);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt32(Size);
      }
      if (HasOffset) {
        output.WriteRawTag(24);
        output.WriteUInt64(Offset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSha1) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Sha1);
      }
      if (HasSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Size);
      }
      if (HasOffset) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Offset);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Slice other) {
      if (other == null) {
        return;
      }
      if (other.HasSha1) {
        Sha1 = other.Sha1;
      }
      if (other.HasSize) {
        Size = other.Size;
      }
      if (other.HasOffset) {
        Offset = other.Offset;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Sha1 = input.ReadBytes();
            break;
          }
          case 16: {
            Size = input.ReadUInt32();
            break;
          }
          case 24: {
            Offset = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Sha1 = input.ReadBytes();
            break;
          }
          case 16: {
            Size = input.ReadUInt32();
            break;
          }
          case 24: {
            Offset = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Archive : pb::IMessage<Archive>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Archive> _parser = new pb::MessageParser<Archive>(() => new Archive());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Archive> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.InstallationBackup.InstallationBackupReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Archive() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Archive(Archive other) : this() {
      _hasBits0 = other._hasBits0;
      filename_ = other.filename_;
      size_ = other.size_;
      slices_ = other.slices_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Archive Clone() {
      return new Archive(this);
    }

    /// <summary>Field number for the "filename" field.</summary>
    public const int FilenameFieldNumber = 1;
    private readonly static string FilenameDefaultValue = "";

    private string filename_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Filename {
      get { return filename_ ?? FilenameDefaultValue; }
      set {
        filename_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "filename" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFilename {
      get { return filename_ != null; }
    }
    /// <summary>Clears the value of the "filename" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFilename() {
      filename_ = null;
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 2;
    private readonly static ulong SizeDefaultValue = 0UL;

    private ulong size_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Size {
      get { if ((_hasBits0 & 1) != 0) { return size_; } else { return SizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        size_ = value;
      }
    }
    /// <summary>Gets whether the "size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "slices" field.</summary>
    public const int SlicesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.InstallationBackup.Slice> _repeated_slices_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.InstallationBackup.Slice.Parser);
    private readonly pbc::RepeatedField<global::Uplay.InstallationBackup.Slice> slices_ = new pbc::RepeatedField<global::Uplay.InstallationBackup.Slice>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.InstallationBackup.Slice> Slices {
      get { return slices_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Archive);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Archive other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Filename != other.Filename) return false;
      if (Size != other.Size) return false;
      if(!slices_.Equals(other.slices_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasFilename) hash ^= Filename.GetHashCode();
      if (HasSize) hash ^= Size.GetHashCode();
      hash ^= slices_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasFilename) {
        output.WriteRawTag(10);
        output.WriteString(Filename);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt64(Size);
      }
      slices_.WriteTo(output, _repeated_slices_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasFilename) {
        output.WriteRawTag(10);
        output.WriteString(Filename);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt64(Size);
      }
      slices_.WriteTo(ref output, _repeated_slices_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasFilename) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Filename);
      }
      if (HasSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Size);
      }
      size += slices_.CalculateSize(_repeated_slices_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Archive other) {
      if (other == null) {
        return;
      }
      if (other.HasFilename) {
        Filename = other.Filename;
      }
      if (other.HasSize) {
        Size = other.Size;
      }
      slices_.Add(other.slices_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Filename = input.ReadString();
            break;
          }
          case 16: {
            Size = input.ReadUInt64();
            break;
          }
          case 26: {
            slices_.AddEntriesFrom(input, _repeated_slices_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Filename = input.ReadString();
            break;
          }
          case 16: {
            Size = input.ReadUInt64();
            break;
          }
          case 26: {
            slices_.AddEntriesFrom(ref input, _repeated_slices_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Disc : pb::IMessage<Disc>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Disc> _parser = new pb::MessageParser<Disc>(() => new Disc());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Disc> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.InstallationBackup.InstallationBackupReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Disc() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Disc(Disc other) : this() {
      _hasBits0 = other._hasBits0;
      number_ = other.number_;
      label_ = other.label_;
      archives_ = other.archives_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Disc Clone() {
      return new Disc(this);
    }

    /// <summary>Field number for the "number" field.</summary>
    public const int NumberFieldNumber = 1;
    private readonly static uint NumberDefaultValue = 0;

    private uint number_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Number {
      get { if ((_hasBits0 & 1) != 0) { return number_; } else { return NumberDefaultValue; } }
      set {
        _hasBits0 |= 1;
        number_ = value;
      }
    }
    /// <summary>Gets whether the "number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumber {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumber() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 2;
    private readonly static string LabelDefaultValue = "";

    private string label_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Label {
      get { return label_ ?? LabelDefaultValue; }
      set {
        label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "label" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLabel {
      get { return label_ != null; }
    }
    /// <summary>Clears the value of the "label" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLabel() {
      label_ = null;
    }

    /// <summary>Field number for the "archives" field.</summary>
    public const int ArchivesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.InstallationBackup.Archive> _repeated_archives_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.InstallationBackup.Archive.Parser);
    private readonly pbc::RepeatedField<global::Uplay.InstallationBackup.Archive> archives_ = new pbc::RepeatedField<global::Uplay.InstallationBackup.Archive>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.InstallationBackup.Archive> Archives {
      get { return archives_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Disc);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Disc other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Number != other.Number) return false;
      if (Label != other.Label) return false;
      if(!archives_.Equals(other.archives_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNumber) hash ^= Number.GetHashCode();
      if (HasLabel) hash ^= Label.GetHashCode();
      hash ^= archives_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNumber) {
        output.WriteRawTag(8);
        output.WriteUInt32(Number);
      }
      if (HasLabel) {
        output.WriteRawTag(18);
        output.WriteString(Label);
      }
      archives_.WriteTo(output, _repeated_archives_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNumber) {
        output.WriteRawTag(8);
        output.WriteUInt32(Number);
      }
      if (HasLabel) {
        output.WriteRawTag(18);
        output.WriteString(Label);
      }
      archives_.WriteTo(ref output, _repeated_archives_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNumber) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Number);
      }
      if (HasLabel) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Label);
      }
      size += archives_.CalculateSize(_repeated_archives_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Disc other) {
      if (other == null) {
        return;
      }
      if (other.HasNumber) {
        Number = other.Number;
      }
      if (other.HasLabel) {
        Label = other.Label;
      }
      archives_.Add(other.archives_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Number = input.ReadUInt32();
            break;
          }
          case 18: {
            Label = input.ReadString();
            break;
          }
          case 26: {
            archives_.AddEntriesFrom(input, _repeated_archives_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Number = input.ReadUInt32();
            break;
          }
          case 18: {
            Label = input.ReadString();
            break;
          }
          case 26: {
            archives_.AddEntriesFrom(ref input, _repeated_archives_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class TextFile : pb::IMessage<TextFile>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TextFile> _parser = new pb::MessageParser<TextFile>(() => new TextFile());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TextFile> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.InstallationBackup.InstallationBackupReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFile() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFile(TextFile other) : this() {
      language_ = other.language_;
      fileName_ = other.fileName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TextFile Clone() {
      return new TextFile(this);
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 1;
    private readonly static string LanguageDefaultValue = "";

    private string language_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_ ?? LanguageDefaultValue; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "language" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLanguage {
      get { return language_ != null; }
    }
    /// <summary>Clears the value of the "language" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLanguage() {
      language_ = null;
    }

    /// <summary>Field number for the "fileName" field.</summary>
    public const int FileNameFieldNumber = 2;
    private readonly static string FileNameDefaultValue = "";

    private string fileName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FileName {
      get { return fileName_ ?? FileNameDefaultValue; }
      set {
        fileName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fileName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFileName {
      get { return fileName_ != null; }
    }
    /// <summary>Clears the value of the "fileName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFileName() {
      fileName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TextFile);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TextFile other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Language != other.Language) return false;
      if (FileName != other.FileName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLanguage) hash ^= Language.GetHashCode();
      if (HasFileName) hash ^= FileName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasLanguage) {
        output.WriteRawTag(10);
        output.WriteString(Language);
      }
      if (HasFileName) {
        output.WriteRawTag(18);
        output.WriteString(FileName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasLanguage) {
        output.WriteRawTag(10);
        output.WriteString(Language);
      }
      if (HasFileName) {
        output.WriteRawTag(18);
        output.WriteString(FileName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasLanguage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (HasFileName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FileName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TextFile other) {
      if (other == null) {
        return;
      }
      if (other.HasLanguage) {
        Language = other.Language;
      }
      if (other.HasFileName) {
        FileName = other.FileName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Language = input.ReadString();
            break;
          }
          case 18: {
            FileName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Language = input.ReadString();
            break;
          }
          case 18: {
            FileName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Autorun : pb::IMessage<Autorun>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Autorun> _parser = new pb::MessageParser<Autorun>(() => new Autorun());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Autorun> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.InstallationBackup.InstallationBackupReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Autorun() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Autorun(Autorun other) : this() {
      gameTitle_ = other.gameTitle_;
      readmeFiles_ = other.readmeFiles_.Clone();
      manualFiles_ = other.manualFiles_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Autorun Clone() {
      return new Autorun(this);
    }

    /// <summary>Field number for the "gameTitle" field.</summary>
    public const int GameTitleFieldNumber = 1;
    private readonly static string GameTitleDefaultValue = "";

    private string gameTitle_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string GameTitle {
      get { return gameTitle_ ?? GameTitleDefaultValue; }
      set {
        gameTitle_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gameTitle" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGameTitle {
      get { return gameTitle_ != null; }
    }
    /// <summary>Clears the value of the "gameTitle" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGameTitle() {
      gameTitle_ = null;
    }

    /// <summary>Field number for the "readmeFiles" field.</summary>
    public const int ReadmeFilesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Uplay.InstallationBackup.TextFile> _repeated_readmeFiles_codec
        = pb::FieldCodec.ForMessage(18, global::Uplay.InstallationBackup.TextFile.Parser);
    private readonly pbc::RepeatedField<global::Uplay.InstallationBackup.TextFile> readmeFiles_ = new pbc::RepeatedField<global::Uplay.InstallationBackup.TextFile>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.InstallationBackup.TextFile> ReadmeFiles {
      get { return readmeFiles_; }
    }

    /// <summary>Field number for the "manualFiles" field.</summary>
    public const int ManualFilesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.InstallationBackup.TextFile> _repeated_manualFiles_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.InstallationBackup.TextFile.Parser);
    private readonly pbc::RepeatedField<global::Uplay.InstallationBackup.TextFile> manualFiles_ = new pbc::RepeatedField<global::Uplay.InstallationBackup.TextFile>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.InstallationBackup.TextFile> ManualFiles {
      get { return manualFiles_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Autorun);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Autorun other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (GameTitle != other.GameTitle) return false;
      if(!readmeFiles_.Equals(other.readmeFiles_)) return false;
      if(!manualFiles_.Equals(other.manualFiles_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasGameTitle) hash ^= GameTitle.GetHashCode();
      hash ^= readmeFiles_.GetHashCode();
      hash ^= manualFiles_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasGameTitle) {
        output.WriteRawTag(10);
        output.WriteString(GameTitle);
      }
      readmeFiles_.WriteTo(output, _repeated_readmeFiles_codec);
      manualFiles_.WriteTo(output, _repeated_manualFiles_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasGameTitle) {
        output.WriteRawTag(10);
        output.WriteString(GameTitle);
      }
      readmeFiles_.WriteTo(ref output, _repeated_readmeFiles_codec);
      manualFiles_.WriteTo(ref output, _repeated_manualFiles_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasGameTitle) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GameTitle);
      }
      size += readmeFiles_.CalculateSize(_repeated_readmeFiles_codec);
      size += manualFiles_.CalculateSize(_repeated_manualFiles_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Autorun other) {
      if (other == null) {
        return;
      }
      if (other.HasGameTitle) {
        GameTitle = other.GameTitle;
      }
      readmeFiles_.Add(other.readmeFiles_);
      manualFiles_.Add(other.manualFiles_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            GameTitle = input.ReadString();
            break;
          }
          case 18: {
            readmeFiles_.AddEntriesFrom(input, _repeated_readmeFiles_codec);
            break;
          }
          case 26: {
            manualFiles_.AddEntriesFrom(input, _repeated_manualFiles_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            GameTitle = input.ReadString();
            break;
          }
          case 18: {
            readmeFiles_.AddEntriesFrom(ref input, _repeated_readmeFiles_codec);
            break;
          }
          case 26: {
            manualFiles_.AddEntriesFrom(ref input, _repeated_manualFiles_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class InstallationBackup : pb::IMessage<InstallationBackup>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstallationBackup> _parser = new pb::MessageParser<InstallationBackup>(() => new InstallationBackup());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InstallationBackup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Uplay.InstallationBackup.InstallationBackupReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallationBackup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallationBackup(InstallationBackup other) : this() {
      _hasBits0 = other._hasBits0;
      version_ = other.version_;
      productId_ = other.productId_;
      discs_ = other.discs_.Clone();
      licenses_ = other.licenses_.Clone();
      manifestSha1_ = other.manifestSha1_;
      environment_ = other.environment_;
      autorun_ = other.autorun_ != null ? other.autorun_.Clone() : null;
      languages_ = other.languages_.Clone();
      sha1_ = other.sha1_;
      productPackUplayIds_ = other.productPackUplayIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallationBackup Clone() {
      return new InstallationBackup(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private readonly static uint VersionDefaultValue = 0;

    private uint version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Version {
      get { if ((_hasBits0 & 1) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "productId" field.</summary>
    public const int ProductIdFieldNumber = 2;
    private readonly static uint ProductIdDefaultValue = 0;

    private uint productId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ProductId {
      get { if ((_hasBits0 & 2) != 0) { return productId_; } else { return ProductIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        productId_ = value;
      }
    }
    /// <summary>Gets whether the "productId" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProductId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "productId" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProductId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "discs" field.</summary>
    public const int DiscsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Uplay.InstallationBackup.Disc> _repeated_discs_codec
        = pb::FieldCodec.ForMessage(26, global::Uplay.InstallationBackup.Disc.Parser);
    private readonly pbc::RepeatedField<global::Uplay.InstallationBackup.Disc> discs_ = new pbc::RepeatedField<global::Uplay.InstallationBackup.Disc>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.InstallationBackup.Disc> Discs {
      get { return discs_; }
    }

    /// <summary>Field number for the "licenses" field.</summary>
    public const int LicensesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Uplay.InstallationBackup.License> _repeated_licenses_codec
        = pb::FieldCodec.ForMessage(34, global::Uplay.InstallationBackup.License.Parser);
    private readonly pbc::RepeatedField<global::Uplay.InstallationBackup.License> licenses_ = new pbc::RepeatedField<global::Uplay.InstallationBackup.License>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Uplay.InstallationBackup.License> Licenses {
      get { return licenses_; }
    }

    /// <summary>Field number for the "manifestSha1" field.</summary>
    public const int ManifestSha1FieldNumber = 5;
    private readonly static string ManifestSha1DefaultValue = "";

    private string manifestSha1_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ManifestSha1 {
      get { return manifestSha1_ ?? ManifestSha1DefaultValue; }
      set {
        manifestSha1_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "manifestSha1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasManifestSha1 {
      get { return manifestSha1_ != null; }
    }
    /// <summary>Clears the value of the "manifestSha1" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearManifestSha1() {
      manifestSha1_ = null;
    }

    /// <summary>Field number for the "environment" field.</summary>
    public const int EnvironmentFieldNumber = 6;
    private readonly static string EnvironmentDefaultValue = "";

    private string environment_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Environment {
      get { return environment_ ?? EnvironmentDefaultValue; }
      set {
        environment_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "environment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEnvironment {
      get { return environment_ != null; }
    }
    /// <summary>Clears the value of the "environment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEnvironment() {
      environment_ = null;
    }

    /// <summary>Field number for the "autorun" field.</summary>
    public const int AutorunFieldNumber = 7;
    private global::Uplay.InstallationBackup.Autorun autorun_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Uplay.InstallationBackup.Autorun Autorun {
      get { return autorun_; }
      set {
        autorun_ = value;
      }
    }

    /// <summary>Field number for the "languages" field.</summary>
    public const int LanguagesFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_languages_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> languages_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Languages {
      get { return languages_; }
    }

    /// <summary>Field number for the "sha1" field.</summary>
    public const int Sha1FieldNumber = 9;
    private readonly static pb::ByteString Sha1DefaultValue = pb::ByteString.Empty;

    private pb::ByteString sha1_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Sha1 {
      get { return sha1_ ?? Sha1DefaultValue; }
      set {
        sha1_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sha1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSha1 {
      get { return sha1_ != null; }
    }
    /// <summary>Clears the value of the "sha1" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSha1() {
      sha1_ = null;
    }

    /// <summary>Field number for the "productPackUplayIds" field.</summary>
    public const int ProductPackUplayIdsFieldNumber = 10;
    private static readonly pb::FieldCodec<uint> _repeated_productPackUplayIds_codec
        = pb::FieldCodec.ForUInt32(80);
    private readonly pbc::RepeatedField<uint> productPackUplayIds_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> ProductPackUplayIds {
      get { return productPackUplayIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InstallationBackup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InstallationBackup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (ProductId != other.ProductId) return false;
      if(!discs_.Equals(other.discs_)) return false;
      if(!licenses_.Equals(other.licenses_)) return false;
      if (ManifestSha1 != other.ManifestSha1) return false;
      if (Environment != other.Environment) return false;
      if (!object.Equals(Autorun, other.Autorun)) return false;
      if(!languages_.Equals(other.languages_)) return false;
      if (Sha1 != other.Sha1) return false;
      if(!productPackUplayIds_.Equals(other.productPackUplayIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVersion) hash ^= Version.GetHashCode();
      if (HasProductId) hash ^= ProductId.GetHashCode();
      hash ^= discs_.GetHashCode();
      hash ^= licenses_.GetHashCode();
      if (HasManifestSha1) hash ^= ManifestSha1.GetHashCode();
      if (HasEnvironment) hash ^= Environment.GetHashCode();
      if (autorun_ != null) hash ^= Autorun.GetHashCode();
      hash ^= languages_.GetHashCode();
      if (HasSha1) hash ^= Sha1.GetHashCode();
      hash ^= productPackUplayIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasVersion) {
        output.WriteRawTag(8);
        output.WriteUInt32(Version);
      }
      if (HasProductId) {
        output.WriteRawTag(16);
        output.WriteUInt32(ProductId);
      }
      discs_.WriteTo(output, _repeated_discs_codec);
      licenses_.WriteTo(output, _repeated_licenses_codec);
      if (HasManifestSha1) {
        output.WriteRawTag(42);
        output.WriteString(ManifestSha1);
      }
      if (HasEnvironment) {
        output.WriteRawTag(50);
        output.WriteString(Environment);
      }
      if (autorun_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Autorun);
      }
      languages_.WriteTo(output, _repeated_languages_codec);
      if (HasSha1) {
        output.WriteRawTag(74);
        output.WriteBytes(Sha1);
      }
      productPackUplayIds_.WriteTo(output, _repeated_productPackUplayIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasVersion) {
        output.WriteRawTag(8);
        output.WriteUInt32(Version);
      }
      if (HasProductId) {
        output.WriteRawTag(16);
        output.WriteUInt32(ProductId);
      }
      discs_.WriteTo(ref output, _repeated_discs_codec);
      licenses_.WriteTo(ref output, _repeated_licenses_codec);
      if (HasManifestSha1) {
        output.WriteRawTag(42);
        output.WriteString(ManifestSha1);
      }
      if (HasEnvironment) {
        output.WriteRawTag(50);
        output.WriteString(Environment);
      }
      if (autorun_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Autorun);
      }
      languages_.WriteTo(ref output, _repeated_languages_codec);
      if (HasSha1) {
        output.WriteRawTag(74);
        output.WriteBytes(Sha1);
      }
      productPackUplayIds_.WriteTo(ref output, _repeated_productPackUplayIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
      }
      if (HasProductId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ProductId);
      }
      size += discs_.CalculateSize(_repeated_discs_codec);
      size += licenses_.CalculateSize(_repeated_licenses_codec);
      if (HasManifestSha1) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ManifestSha1);
      }
      if (HasEnvironment) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Environment);
      }
      if (autorun_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Autorun);
      }
      size += languages_.CalculateSize(_repeated_languages_codec);
      if (HasSha1) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Sha1);
      }
      size += productPackUplayIds_.CalculateSize(_repeated_productPackUplayIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InstallationBackup other) {
      if (other == null) {
        return;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      if (other.HasProductId) {
        ProductId = other.ProductId;
      }
      discs_.Add(other.discs_);
      licenses_.Add(other.licenses_);
      if (other.HasManifestSha1) {
        ManifestSha1 = other.ManifestSha1;
      }
      if (other.HasEnvironment) {
        Environment = other.Environment;
      }
      if (other.autorun_ != null) {
        if (autorun_ == null) {
          Autorun = new global::Uplay.InstallationBackup.Autorun();
        }
        Autorun.MergeFrom(other.Autorun);
      }
      languages_.Add(other.languages_);
      if (other.HasSha1) {
        Sha1 = other.Sha1;
      }
      productPackUplayIds_.Add(other.productPackUplayIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Version = input.ReadUInt32();
            break;
          }
          case 16: {
            ProductId = input.ReadUInt32();
            break;
          }
          case 26: {
            discs_.AddEntriesFrom(input, _repeated_discs_codec);
            break;
          }
          case 34: {
            licenses_.AddEntriesFrom(input, _repeated_licenses_codec);
            break;
          }
          case 42: {
            ManifestSha1 = input.ReadString();
            break;
          }
          case 50: {
            Environment = input.ReadString();
            break;
          }
          case 58: {
            if (autorun_ == null) {
              Autorun = new global::Uplay.InstallationBackup.Autorun();
            }
            input.ReadMessage(Autorun);
            break;
          }
          case 66: {
            languages_.AddEntriesFrom(input, _repeated_languages_codec);
            break;
          }
          case 74: {
            Sha1 = input.ReadBytes();
            break;
          }
          case 82:
          case 80: {
            productPackUplayIds_.AddEntriesFrom(input, _repeated_productPackUplayIds_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Version = input.ReadUInt32();
            break;
          }
          case 16: {
            ProductId = input.ReadUInt32();
            break;
          }
          case 26: {
            discs_.AddEntriesFrom(ref input, _repeated_discs_codec);
            break;
          }
          case 34: {
            licenses_.AddEntriesFrom(ref input, _repeated_licenses_codec);
            break;
          }
          case 42: {
            ManifestSha1 = input.ReadString();
            break;
          }
          case 50: {
            Environment = input.ReadString();
            break;
          }
          case 58: {
            if (autorun_ == null) {
              Autorun = new global::Uplay.InstallationBackup.Autorun();
            }
            input.ReadMessage(Autorun);
            break;
          }
          case 66: {
            languages_.AddEntriesFrom(ref input, _repeated_languages_codec);
            break;
          }
          case 74: {
            Sha1 = input.ReadBytes();
            break;
          }
          case 82:
          case 80: {
            productPackUplayIds_.AddEntriesFrom(ref input, _repeated_productPackUplayIds_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
